/* Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *     * Neither the name of The Linux Foundation nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#define LOG_TAG "QCameraParameters"

// To remove
#include <cutils/properties.h>

// System dependencies
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <utils/Errors.h>
#define SYSINFO_H <SYSTEM_HEADER_PREFIX/sysinfo.h>
#include SYSINFO_H
#include "gralloc_priv.h"
#include "graphics.h"

// Camera dependencies
#include "QCameraBufferMaps.h"
#include "QCamera2HWI.h"
#include "QCameraParameters.h"
#include "QCameraTrace.h"

extern "C" {
#include "mm_camera_dbg.h"
}

#define PI 3.14159265
#define ASPECT_TOLERANCE 0.001
#define CAMERA_DEFAULT_LONGSHOT_STAGES 4
#define CAMERA_MIN_LONGSHOT_STAGES 2
#define FOCUS_PERCISION 0.0000001


namespace qcamera {
// Parameter keys to communicate between camera application and driver.
const char QCameraParameters::KEY_QC_SUPPORTED_HFR_SIZES[] = "hfr-size-values";
const char QCameraParameters::KEY_QC_PREVIEW_FRAME_RATE_MODE[] = "preview-frame-rate-mode";
const char QCameraParameters::KEY_QC_SUPPORTED_PREVIEW_FRAME_RATE_MODES[] = "preview-frame-rate-modes";
const char QCameraParameters::KEY_QC_PREVIEW_FRAME_RATE_AUTO_MODE[] = "frame-rate-auto";
const char QCameraParameters::KEY_QC_PREVIEW_FRAME_RATE_FIXED_MODE[] = "frame-rate-fixed";
const char QCameraParameters::KEY_QC_TOUCH_AF_AEC[] = "touch-af-aec";
const char QCameraParameters::KEY_QC_SUPPORTED_TOUCH_AF_AEC[] = "touch-af-aec-values";
const char QCameraParameters::KEY_QC_TOUCH_INDEX_AEC[] = "touch-index-aec";
const char QCameraParameters::KEY_QC_TOUCH_INDEX_AF[] = "touch-index-af";
const char QCameraParameters::KEY_QC_SCENE_DETECT[] = "scene-detect";
const char QCameraParameters::KEY_QC_SUPPORTED_SCENE_DETECT[] = "scene-detect-values";
const char QCameraParameters::KEY_QC_ISO_MODE[] = "iso";
const char QCameraParameters::KEY_QC_CONTINUOUS_ISO[] = "continuous-iso";
const char QCameraParameters::KEY_QC_MIN_ISO[] = "min-iso";
const char QCameraParameters::KEY_QC_MAX_ISO[] = "max-iso";
const char QCameraParameters::KEY_QC_SUPPORTED_ISO_MODES[] = "iso-values";
const char QCameraParameters::KEY_QC_EXPOSURE_TIME[] = "exposure-time";
const char QCameraParameters::KEY_QC_MIN_EXPOSURE_TIME[] = "min-exposure-time";
const char QCameraParameters::KEY_QC_MAX_EXPOSURE_TIME[] = "max-exposure-time";
const char QCameraParameters::KEY_QC_CURRENT_EXPOSURE_TIME[] = "cur-exposure-time";
const char QCameraParameters::KEY_QC_CURRENT_ISO[] = "cur-iso";
const char QCameraParameters::KEY_QC_LENSSHADE[] = "lensshade";
const char QCameraParameters::KEY_QC_SUPPORTED_LENSSHADE_MODES[] = "lensshade-values";
const char QCameraParameters::KEY_QC_AUTO_EXPOSURE[] = "auto-exposure";
const char QCameraParameters::KEY_QC_SUPPORTED_AUTO_EXPOSURE[] = "auto-exposure-values";
const char QCameraParameters::KEY_QC_DENOISE[] = "denoise";
const char QCameraParameters::KEY_QC_SUPPORTED_DENOISE[] = "denoise-values";
const char QCameraParameters::KEY_QC_FOCUS_ALGO[] = "selectable-zone-af";
const char QCameraParameters::KEY_QC_SUPPORTED_FOCUS_ALGOS[] = "selectable-zone-af-values";
const char QCameraParameters::KEY_QC_MANUAL_FOCUS_POSITION[] = "manual-focus-position";
const char QCameraParameters::KEY_QC_MANUAL_FOCUS_POS_TYPE[] = "manual-focus-pos-type";
const char QCameraParameters::KEY_QC_MIN_FOCUS_POS_INDEX[] = "min-focus-pos-index";
const char QCameraParameters::KEY_QC_MAX_FOCUS_POS_INDEX[] = "max-focus-pos-index";
const char QCameraParameters::KEY_QC_MIN_FOCUS_POS_DAC[] = "min-focus-pos-dac";
const char QCameraParameters::KEY_QC_MAX_FOCUS_POS_DAC[] = "max-focus-pos-dac";
const char QCameraParameters::KEY_QC_MIN_FOCUS_POS_RATIO[] = "min-focus-pos-ratio";
const char QCameraParameters::KEY_QC_MAX_FOCUS_POS_RATIO[] = "max-focus-pos-ratio";
const char QCameraParameters::KEY_QC_FOCUS_POSITION_SCALE[] = "cur-focus-scale";
const char QCameraParameters::KEY_QC_MIN_FOCUS_POS_DIOPTER[] = "min-focus-pos-diopter";
const char QCameraParameters::KEY_QC_MAX_FOCUS_POS_DIOPTER[] = "max-focus-pos-diopter";
const char QCameraParameters::KEY_QC_FOCUS_POSITION_DIOPTER[] = "cur-focus-diopter";
const char QCameraParameters::KEY_QC_FACE_DETECTION[] = "face-detection";
const char QCameraParameters::KEY_QC_SUPPORTED_FACE_DETECTION[] = "face-detection-values";
const char QCameraParameters::KEY_QC_FACE_RECOGNITION[] = "face-recognition";
const char QCameraParameters::KEY_QC_SUPPORTED_FACE_RECOGNITION[] = "face-recognition-values";
const char QCameraParameters::KEY_QC_MEMORY_COLOR_ENHANCEMENT[] = "mce";
const char QCameraParameters::KEY_QC_SUPPORTED_MEM_COLOR_ENHANCE_MODES[] = "mce-values";
const char QCameraParameters::KEY_QC_DIS[] = "dis";
const char QCameraParameters::KEY_QC_OIS[] = "ois";
const char QCameraParameters::KEY_QC_SUPPORTED_DIS_MODES[] = "dis-values";
const char QCameraParameters::KEY_QC_SUPPORTED_OIS_MODES[] = "ois-values";
const char QCameraParameters::KEY_QC_VIDEO_HIGH_FRAME_RATE[] = "video-hfr";
const char QCameraParameters::KEY_QC_VIDEO_HIGH_SPEED_RECORDING[] = "video-hsr";
const char QCameraParameters::KEY_QC_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES[] = "video-hfr-values";
const char QCameraParameters::KEY_QC_REDEYE_REDUCTION[] = "redeye-reduction";
const char QCameraParameters::KEY_QC_SUPPORTED_REDEYE_REDUCTION[] = "redeye-reduction-values";
const char QCameraParameters::KEY_QC_HIGH_DYNAMIC_RANGE_IMAGING[] = "hdr";
const char QCameraParameters::KEY_QC_SUPPORTED_HDR_IMAGING_MODES[] = "hdr-values";
const char QCameraParameters::KEY_QC_ZSL[] = "zsl";
const char QCameraParameters::KEY_QC_SUPPORTED_ZSL_MODES[] = "zsl-values";
const char QCameraParameters::KEY_QC_ZSL_BURST_INTERVAL[] = "capture-burst-interval";
const char QCameraParameters::KEY_QC_ZSL_BURST_LOOKBACK[] = "capture-burst-retroactive";
const char QCameraParameters::KEY_QC_ZSL_QUEUE_DEPTH[] = "capture-burst-queue-depth";
const char QCameraParameters::KEY_QC_CAMERA_MODE[] = "camera-mode";
const char QCameraParameters::KEY_QC_AE_BRACKET_HDR[] = "ae-bracket-hdr";
const char QCameraParameters::KEY_QC_SUPPORTED_AE_BRACKET_MODES[] = "ae-bracket-hdr-values";
const char QCameraParameters::KEY_QC_SUPPORTED_RAW_FORMATS[] = "raw-format-values";
const char QCameraParameters::KEY_QC_RAW_FORMAT[] = "raw-format";
const char QCameraParameters::KEY_QC_ORIENTATION[] = "orientation";
const char QCameraParameters::KEY_QC_SELECTABLE_ZONE_AF[] = "selectable-zone-af";
const char QCameraParameters::KEY_QC_CAPTURE_BURST_EXPOSURE[] = "capture-burst-exposures";
const char QCameraParameters::KEY_QC_NUM_SNAPSHOT_PER_SHUTTER[] = "num-snaps-per-shutter";
const char QCameraParameters::KEY_QC_NUM_RETRO_BURST_PER_SHUTTER[] = "num-retro-burst-per-shutter";
const char QCameraParameters::KEY_QC_SNAPSHOT_BURST_LED_ON_PERIOD[] = "zsl-burst-led-on-period";
const char QCameraParameters::KEY_QC_NO_DISPLAY_MODE[] = "no-display-mode";
const char QCameraParameters::KEY_QC_RAW_PICUTRE_SIZE[] = "raw-size";
const char QCameraParameters::KEY_QC_SUPPORTED_SKIN_TONE_ENHANCEMENT_MODES[] = "skinToneEnhancement-values";
const char QCameraParameters::KEY_QC_SUPPORTED_LIVESNAPSHOT_SIZES[] = "supported-live-snapshot-sizes";
const char QCameraParameters::KEY_QC_SUPPORTED_HDR_NEED_1X[] = "hdr-need-1x-values";
const char QCameraParameters::KEY_QC_HDR_NEED_1X[] = "hdr-need-1x";
const char QCameraParameters::KEY_QC_PREVIEW_FLIP[] = "preview-flip";
const char QCameraParameters::KEY_QC_VIDEO_FLIP[] = "video-flip";
const char QCameraParameters::KEY_QC_SNAPSHOT_PICTURE_FLIP[] = "snapshot-picture-flip";
const char QCameraParameters::KEY_QC_SUPPORTED_FLIP_MODES[] = "flip-mode-values";
const char QCameraParameters::KEY_QC_VIDEO_HDR[] = "video-hdr";
const char QCameraParameters::KEY_QC_SENSOR_HDR[] = "sensor-hdr";
const char QCameraParameters::KEY_QC_VT_ENABLE[] = "avtimer";
const char QCameraParameters::KEY_QC_SUPPORTED_VIDEO_HDR_MODES[] = "video-hdr-values";
const char QCameraParameters::KEY_QC_SUPPORTED_SENSOR_HDR_MODES[] = "sensor-hdr-values";
const char QCameraParameters::KEY_QC_AUTO_HDR_ENABLE [] = "auto-hdr-enable";
const char QCameraParameters::KEY_QC_SNAPSHOT_BURST_NUM[] = "snapshot-burst-num";
const char QCameraParameters::KEY_QC_SNAPSHOT_FD_DATA[] = "snapshot-fd-data-enable";
const char QCameraParameters::KEY_QC_TINTLESS_ENABLE[] = "tintless";
const char QCameraParameters::KEY_QC_SCENE_SELECTION[] = "scene-selection";
const char QCameraParameters::KEY_QC_CDS_MODE[] = "cds-mode";
const char QCameraParameters::KEY_QC_VIDEO_CDS_MODE[] = "video-cds-mode";
const char QCameraParameters::KEY_QC_SUPPORTED_CDS_MODES[] = "cds-mode-values";
const char QCameraParameters::KEY_QC_SUPPORTED_VIDEO_CDS_MODES[] = "video-cds-mode-values";
const char QCameraParameters::KEY_QC_TNR_MODE[] = "tnr-mode";
const char QCameraParameters::KEY_QC_VIDEO_TNR_MODE[] = "video-tnr-mode";
const char QCameraParameters::KEY_QC_SUPPORTED_TNR_MODES[] = "tnr-mode-values";
const char QCameraParameters::KEY_QC_SUPPORTED_VIDEO_TNR_MODES[] = "video-tnr-mode-values";
const char QCameraParameters::KEY_QC_VIDEO_ROTATION[] = "video-rotation";
const char QCameraParameters::KEY_QC_SUPPORTED_VIDEO_ROTATION_VALUES[] = "video-rotation-values";
const char QCameraParameters::KEY_QC_AF_BRACKET[] = "af-bracket";
const char QCameraParameters::KEY_QC_SUPPORTED_AF_BRACKET_MODES[] = "af-bracket-values";
const char QCameraParameters::KEY_QC_RE_FOCUS[] = "re-focus";
const char QCameraParameters::KEY_QC_SUPPORTED_RE_FOCUS_MODES[] = "re-focus-values";
const char QCameraParameters::KEY_QC_CHROMA_FLASH[] = "chroma-flash";
const char QCameraParameters::KEY_QC_SUPPORTED_CHROMA_FLASH_MODES[] = "chroma-flash-values";
const char QCameraParameters::KEY_QC_OPTI_ZOOM[] = "opti-zoom";
const char QCameraParameters::KEY_QC_SEE_MORE[] = "see-more";
const char QCameraParameters::KEY_QC_STILL_MORE[] = "still-more";
const char QCameraParameters::KEY_QC_SUPPORTED_OPTI_ZOOM_MODES[] = "opti-zoom-values";
const char QCameraParameters::KEY_QC_HDR_MODE[] = "hdr-mode";
const char QCameraParameters::KEY_QC_SUPPORTED_KEY_QC_HDR_MODES[] = "hdr-mode-values";
const char QCameraParameters::KEY_QC_TRUE_PORTRAIT[] = "true-portrait";
const char QCameraParameters::KEY_QC_SUPPORTED_TRUE_PORTRAIT_MODES[] = "true-portrait-values";
const char QCameraParameters::KEY_QC_SUPPORTED_SEE_MORE_MODES[] = "see-more-values";
const char QCameraParameters::KEY_QC_SUPPORTED_STILL_MORE_MODES[] = "still-more-values";
const char QCameraParameters::KEY_INTERNAL_PERVIEW_RESTART[] = "internal-restart";
const char QCameraParameters::KEY_QC_RDI_MODE[] = "rdi-mode";
const char QCameraParameters::KEY_QC_SUPPORTED_RDI_MODES[] = "rdi-mode-values";
const char QCameraParameters::KEY_QC_SECURE_MODE[] = "secure-mode";
const char QCameraParameters::KEY_QC_SUPPORTED_SECURE_MODES[] = "secure-mode-values";
const char QCameraParameters::ISO_HJR[] = "ISO_HJR";
const char QCameraParameters::KEY_QC_AUTO_HDR_SUPPORTED[] = "auto-hdr-supported";
const char QCameraParameters::KEY_QC_LONGSHOT_SUPPORTED[] = "longshot-supported";
const char QCameraParameters::KEY_QC_ZSL_HDR_SUPPORTED[] = "zsl-hdr-supported";
const char QCameraParameters::KEY_QC_WB_MANUAL_CCT[] = "wb-manual-cct";
const char QCameraParameters::KEY_QC_MIN_WB_CCT[] = "min-wb-cct";
const char QCameraParameters::KEY_QC_MAX_WB_CCT[] = "max-wb-cct";

const char QCameraParameters::KEY_QC_MANUAL_WB_GAINS[] = "manual-wb-gains";
const char QCameraParameters::KEY_QC_MIN_WB_GAIN[] = "min-wb-gain";
const char QCameraParameters::KEY_QC_MAX_WB_GAIN[] = "max-wb-gain";

const char QCameraParameters::KEY_QC_MANUAL_WB_TYPE[] = "manual-wb-type";
const char QCameraParameters::KEY_QC_MANUAL_WB_VALUE[] = "manual-wb-value";

const char QCameraParameters::WHITE_BALANCE_MANUAL[] = "manual";
const char QCameraParameters::FOCUS_MODE_MANUAL_POSITION[] = "manual";
const char QCameraParameters::KEY_QC_CACHE_VIDEO_BUFFERS[] = "cache-video-buffers";

const char QCameraParameters::KEY_QC_LONG_SHOT[] = "long-shot";
const char QCameraParameters::KEY_QC_INITIAL_EXPOSURE_INDEX[] = "initial-exp-index";
const char QCameraParameters::KEY_QC_INSTANT_AEC[] = "instant-aec";
const char QCameraParameters::KEY_QC_INSTANT_CAPTURE[] = "instant-capture";
const char QCameraParameters::KEY_QC_INSTANT_AEC_SUPPORTED_MODES[] = "instant-aec-values";
const char QCameraParameters::KEY_QC_INSTANT_CAPTURE_SUPPORTED_MODES[] = "instant-capture-values";
const char QCameraParameters::KEY_QC_LED_CALIBRATION_MODES[] = "led-calibration-mode";

// Values for effect settings.
const char QCameraParameters::EFFECT_EMBOSS[] = "emboss";
const char QCameraParameters::EFFECT_SKETCH[] = "sketch";
const char QCameraParameters::EFFECT_NEON[] = "neon";
const char QCameraParameters::EFFECT_BEAUTY[] = "beauty";


// Values for auto exposure settings.
const char QCameraParameters::TOUCH_AF_AEC_OFF[] = "touch-off";
const char QCameraParameters::TOUCH_AF_AEC_ON[] = "touch-on";

// Values for scene mode settings.
const char QCameraParameters::SCENE_MODE_ASD[] = "asd";   // corresponds to CAMERA_BESTSHOT_AUTO in HAL
const char QCameraParameters::SCENE_MODE_BACKLIGHT[] = "backlight";
const char QCameraParameters::SCENE_MODE_FLOWERS[] = "flowers";
const char QCameraParameters::SCENE_MODE_AR[] = "AR";
const char QCameraParameters::SCENE_MODE_HDR[] = "hdr";

// Formats for setPreviewFormat and setPictureFormat.
const char QCameraParameters::PIXEL_FORMAT_YUV420SP_ADRENO[] = "yuv420sp-adreno";
const char QCameraParameters::PIXEL_FORMAT_YV12[] = "yuv420p";
const char QCameraParameters::PIXEL_FORMAT_NV12[] = "nv12";
const char QCameraParameters::QC_PIXEL_FORMAT_NV12_VENUS[] = "nv12-venus";

// Values for raw image formats
const char QCameraParameters::QC_PIXEL_FORMAT_YUV_RAW_8BIT_YUYV[] = "yuv-raw8-yuyv";
const char QCameraParameters::QC_PIXEL_FORMAT_YUV_RAW_8BIT_YVYU[] = "yuv-raw8-yvyu";
const char QCameraParameters::QC_PIXEL_FORMAT_YUV_RAW_8BIT_UYVY[] = "yuv-raw8-uyvy";
const char QCameraParameters::QC_PIXEL_FORMAT_YUV_RAW_8BIT_VYUY[] = "yuv-raw8-vyuy";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_8GBRG[] = "bayer-qcom-8gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_8GRBG[] = "bayer-qcom-8grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_8RGGB[] = "bayer-qcom-8rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_8BGGR[] = "bayer-qcom-8bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_10GBRG[] = "bayer-qcom-10gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_10GRBG[] = "bayer-qcom-10grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_10RGGB[] = "bayer-qcom-10rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_10BGGR[] = "bayer-qcom-10bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_12GBRG[] = "bayer-qcom-12gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_12GRBG[] = "bayer-qcom-12grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_12RGGB[] = "bayer-qcom-12rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_12BGGR[] = "bayer-qcom-12bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_14GBRG[] = "bayer-qcom-14gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_14GRBG[] = "bayer-qcom-14grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_14RGGB[] = "bayer-qcom-14rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_QCOM_RAW_14BGGR[] = "bayer-qcom-14bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_8GBRG[] = "bayer-mipi-8gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_8GRBG[] = "bayer-mipi-8grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_8RGGB[] = "bayer-mipi-8rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_8BGGR[] = "bayer-mipi-8bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_10GBRG[] = "bayer-mipi-10gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_10GRBG[] = "bayer-mipi-10grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_10RGGB[] = "bayer-mipi-10rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_10BGGR[] = "bayer-mipi-10bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_12GBRG[] = "bayer-mipi-12gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_12GRBG[] = "bayer-mipi-12grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_12RGGB[] = "bayer-mipi-12rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_12BGGR[] = "bayer-mipi-12bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_14GBRG[] = "bayer-mipi-14gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_14GRBG[] = "bayer-mipi-14grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_14RGGB[] = "bayer-mipi-14rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_MIPI_RAW_14BGGR[] = "bayer-mipi-14bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_8GBRG[] = "bayer-ideal-qcom-8gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_8GRBG[] = "bayer-ideal-qcom-8grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_8RGGB[] = "bayer-ideal-qcom-8rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_8BGGR[] = "bayer-ideal-qcom-8bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_10GBRG[] = "bayer-ideal-qcom-10gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_10GRBG[] = "bayer-ideal-qcom-10grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_10RGGB[] = "bayer-ideal-qcom-10rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_10BGGR[] = "bayer-ideal-qcom-10bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_12GBRG[] = "bayer-ideal-qcom-12gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_12GRBG[] = "bayer-ideal-qcom-12grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_12RGGB[] = "bayer-ideal-qcom-12rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_12BGGR[] = "bayer-ideal-qcom-12bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_14GBRG[] = "bayer-ideal-qcom-14gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_14GRBG[] = "bayer-ideal-qcom-14grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_14RGGB[] = "bayer-ideal-qcom-14rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_14BGGR[] = "bayer-ideal-qcom-14bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_8GBRG[] = "bayer-ideal-mipi-8gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_8GRBG[] = "bayer-ideal-mipi-8grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_8RGGB[] = "bayer-ideal-mipi-8rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_8BGGR[] = "bayer-ideal-mipi-8bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_10GBRG[] = "bayer-ideal-mipi-10gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_10GRBG[] = "bayer-ideal-mipi-10grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_10RGGB[] = "bayer-ideal-mipi-10rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_10BGGR[] = "bayer-ideal-mipi-10bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_12GBRG[] = "bayer-ideal-mipi-12gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_12GRBG[] = "bayer-ideal-mipi-12grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_12RGGB[] = "bayer-ideal-mipi-12rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_12BGGR[] = "bayer-ideal-mipi-12bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_14GBRG[] = "bayer-ideal-mipi-14gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_14GRBG[] = "bayer-ideal-mipi-14grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_14RGGB[] = "bayer-ideal-mipi-14rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_14BGGR[] = "bayer-ideal-mipi-14bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN8_8GBRG[] = "bayer-ideal-plain8-8gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN8_8GRBG[] = "bayer-ideal-plain8-8grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN8_8RGGB[] = "bayer-ideal-plain8-8rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN8_8BGGR[] = "bayer-ideal-plain8-8bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_8GBRG[] = "bayer-ideal-plain16-8gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_8GRBG[] = "bayer-ideal-plain16-8grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_8RGGB[] = "bayer-ideal-plain16-8rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_8BGGR[] = "bayer-ideal-plain16-8bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_10GBRG[] = "bayer-ideal-plain16-10gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_10GRBG[] = "bayer-ideal-plain16-10grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_10RGGB[] = "bayer-ideal-plain16-10rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_10BGGR[] = "bayer-ideal-plain16-10bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_12GBRG[] = "bayer-ideal-plain16-12gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_12GRBG[] = "bayer-ideal-plain16-12grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_12RGGB[] = "bayer-ideal-plain16-12rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_12BGGR[] = "bayer-ideal-plain16-12bggr";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_14GBRG[] = "bayer-ideal-plain16-14gbrg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_14GRBG[] = "bayer-ideal-plain16-14grbg";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_14RGGB[] = "bayer-ideal-plain16-14rggb";
const char QCameraParameters::QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_14BGGR[] = "bayer-ideal-plain16-14bggr";

// Values for ISO Settings
const char QCameraParameters::ISO_AUTO[] = "auto";
const char QCameraParameters::ISO_100[] = "ISO100";
const char QCameraParameters::ISO_200[] = "ISO200";
const char QCameraParameters::ISO_400[] = "ISO400";
const char QCameraParameters::ISO_800[] = "ISO800";
const char QCameraParameters::ISO_1600[] = "ISO1600";
const char QCameraParameters::ISO_3200[] = "ISO3200";
const char QCameraParameters::ISO_MANUAL[] = "manual";


// Values for auto exposure settings.
const char QCameraParameters::AUTO_EXPOSURE_FRAME_AVG[] = "frame-average";
const char QCameraParameters::AUTO_EXPOSURE_CENTER_WEIGHTED[] = "center-weighted";
const char QCameraParameters::AUTO_EXPOSURE_SPOT_METERING[] = "spot-metering";
const char QCameraParameters::AUTO_EXPOSURE_SMART_METERING[] = "smart-metering";
const char QCameraParameters::AUTO_EXPOSURE_USER_METERING[] = "user-metering";
const char QCameraParameters::AUTO_EXPOSURE_SPOT_METERING_ADV[] = "spot-metering-adv";
const char QCameraParameters::AUTO_EXPOSURE_CENTER_WEIGHTED_ADV[] = "center-weighted-adv";

// Values for instant AEC modes
const char QCameraParameters::KEY_QC_INSTANT_AEC_DISABLE[] = "0";
const char QCameraParameters::KEY_QC_INSTANT_AEC_AGGRESSIVE_AEC[] = "1";
const char QCameraParameters::KEY_QC_INSTANT_AEC_FAST_AEC[] = "2";

// Values for instant capture modes
const char QCameraParameters::KEY_QC_INSTANT_CAPTURE_DISABLE[] = "0";
const char QCameraParameters::KEY_QC_INSTANT_CAPTURE_AGGRESSIVE_AEC[] = "1";
const char QCameraParameters::KEY_QC_INSTANT_CAPTURE_FAST_AEC[] = "2";

//Values for led calibration mode
const char QCameraParameters::KEY_QC_LED_CALIBRATION_OFF[] = "0";
const char QCameraParameters::KEY_QC_LED_CALIBRATION_DUAL[] = "1";
const char QCameraParameters::KEY_QC_LED_CALIBRATION_SINGLE[] = "2";

const char QCameraParameters::KEY_QC_GPS_LATITUDE_REF[] = "gps-latitude-ref";
const char QCameraParameters::KEY_QC_GPS_LONGITUDE_REF[] = "gps-longitude-ref";
const char QCameraParameters::KEY_QC_GPS_ALTITUDE_REF[] = "gps-altitude-ref";
const char QCameraParameters::KEY_QC_GPS_STATUS[] = "gps-status";

const char QCameraParameters::KEY_QC_HISTOGRAM[] = "histogram";
const char QCameraParameters::KEY_QC_SUPPORTED_HISTOGRAM_MODES[] = "histogram-values";

const char QCameraParameters::VALUE_ENABLE[] = "enable";
const char QCameraParameters::VALUE_DISABLE[] = "disable";
const char QCameraParameters::VALUE_OFF[] = "off";
const char QCameraParameters::VALUE_ON[] = "on";
const char QCameraParameters::VALUE_TRUE[] = "true";
const char QCameraParameters::VALUE_FALSE[] = "false";

const char QCameraParameters::VALUE_FAST[] = "fast";
const char QCameraParameters::VALUE_HIGH_QUALITY[] = "high-quality";

const char QCameraParameters::KEY_QC_SHARPNESS[] = "sharpness";
const char QCameraParameters::KEY_QC_MIN_SHARPNESS[] = "min-sharpness";
const char QCameraParameters::KEY_QC_MAX_SHARPNESS[] = "max-sharpness";
const char QCameraParameters::KEY_QC_SHARPNESS_STEP[] = "sharpness-step";
const char QCameraParameters::KEY_QC_CONTRAST[] = "contrast";
const char QCameraParameters::KEY_QC_MIN_CONTRAST[] = "min-contrast";
const char QCameraParameters::KEY_QC_MAX_CONTRAST[] = "max-contrast";
const char QCameraParameters::KEY_QC_CONTRAST_STEP[] = "contrast-step";
const char QCameraParameters::KEY_QC_SATURATION[] = "saturation";
const char QCameraParameters::KEY_QC_MIN_SATURATION[] = "min-saturation";
const char QCameraParameters::KEY_QC_MAX_SATURATION[] = "max-saturation";
const char QCameraParameters::KEY_QC_SATURATION_STEP[] = "saturation-step";
const char QCameraParameters::KEY_QC_BRIGHTNESS[] = "luma-adaptation";
const char QCameraParameters::KEY_QC_MIN_BRIGHTNESS[] = "min-brightness";
const char QCameraParameters::KEY_QC_MAX_BRIGHTNESS[] = "max-brightness";
const char QCameraParameters::KEY_QC_BRIGHTNESS_STEP[] = "brightness-step";
const char QCameraParameters::KEY_QC_SCE_FACTOR[] = "skinToneEnhancement";
const char QCameraParameters::KEY_QC_MIN_SCE_FACTOR[] = "min-sce-factor";
const char QCameraParameters::KEY_QC_MAX_SCE_FACTOR[] = "max-sce-factor";
const char QCameraParameters::KEY_QC_SCE_FACTOR_STEP[] = "sce-factor-step";

const char QCameraParameters::KEY_QC_MAX_NUM_REQUESTED_FACES[] = "qc-max-num-requested-faces";

//Values for DENOISE
const char QCameraParameters::DENOISE_OFF[] = "denoise-off";
const char QCameraParameters::DENOISE_ON[] = "denoise-on";

// Values for selectable zone af Settings
const char QCameraParameters::FOCUS_ALGO_AUTO[] = "auto";
const char QCameraParameters::FOCUS_ALGO_SPOT_METERING[] = "spot-metering";
const char QCameraParameters::FOCUS_ALGO_CENTER_WEIGHTED[] = "center-weighted";
const char QCameraParameters::FOCUS_ALGO_FRAME_AVERAGE[] = "frame-average";

// Values for HFR settings.
const char QCameraParameters::VIDEO_HFR_OFF[] = "off";
const char QCameraParameters::VIDEO_HFR_2X[] = "60";
const char QCameraParameters::VIDEO_HFR_3X[] = "90";
const char QCameraParameters::VIDEO_HFR_4X[] = "120";
const char QCameraParameters::VIDEO_HFR_5X[] = "150";
const char QCameraParameters::VIDEO_HFR_6X[] = "180";
const char QCameraParameters::VIDEO_HFR_7X[] = "210";
const char QCameraParameters::VIDEO_HFR_8X[] = "240";
const char QCameraParameters::VIDEO_HFR_9X[] = "480";

// Values for HDR Bracketing settings.
const char QCameraParameters::AE_BRACKET_OFF[] = "Off";
const char QCameraParameters::AE_BRACKET[] = "AE-Bracket";

// Values for AF Bracketing setting.
const char QCameraParameters::AF_BRACKET_OFF[] = "af-bracket-off";
const char QCameraParameters::AF_BRACKET_ON[] = "af-bracket-on";

// Values for Refocus setting.
const char QCameraParameters::RE_FOCUS_OFF[] = "re-focus-off";
const char QCameraParameters::RE_FOCUS_ON[] = "re-focus-on";

// Values for Chroma Flash setting.
const char QCameraParameters::CHROMA_FLASH_OFF[] = "chroma-flash-off";
const char QCameraParameters::CHROMA_FLASH_ON[] = "chroma-flash-on";

// Values for Opti Zoom setting.
const char QCameraParameters::OPTI_ZOOM_OFF[] = "opti-zoom-off";
const char QCameraParameters::OPTI_ZOOM_ON[] = "opti-zoom-on";

// Values for Still More setting.
const char QCameraParameters::STILL_MORE_OFF[] = "still-more-off";
const char QCameraParameters::STILL_MORE_ON[] = "still-more-on";

// Values for HDR mode setting.
const char QCameraParameters::HDR_MODE_SENSOR[] = "hdr-mode-sensor";
const char QCameraParameters::HDR_MODE_MULTI_FRAME[] = "hdr-mode-multiframe";

// Values for True Portrait setting.
const char QCameraParameters::TRUE_PORTRAIT_OFF[] = "true-portrait-off";
const char QCameraParameters::TRUE_PORTRAIT_ON[] = "true-portrait-on";

// Values for FLIP settings.
const char QCameraParameters::FLIP_MODE_OFF[] = "off";
const char QCameraParameters::FLIP_MODE_V[] = "flip-v";
const char QCameraParameters::FLIP_MODE_H[] = "flip-h";
const char QCameraParameters::FLIP_MODE_VH[] = "flip-vh";

const char QCameraParameters::CDS_MODE_OFF[] = "off";
const char QCameraParameters::CDS_MODE_ON[] = "on";
const char QCameraParameters::CDS_MODE_AUTO[] = "auto";

// Values for video rotation settings.
const char QCameraParameters::VIDEO_ROTATION_0[] = "0";
const char QCameraParameters::VIDEO_ROTATION_90[] = "90";
const char QCameraParameters::VIDEO_ROTATION_180[] = "180";
const char QCameraParameters::VIDEO_ROTATION_270[] = "270";

const char QCameraParameters::KEY_QC_SUPPORTED_MANUAL_FOCUS_MODES[] = "manual-focus-modes";
const char QCameraParameters::KEY_QC_SUPPORTED_MANUAL_EXPOSURE_MODES[] = "manual-exposure-modes";
const char QCameraParameters::KEY_QC_SUPPORTED_MANUAL_WB_MODES[] = "manual-wb-modes";
const char QCameraParameters::KEY_QC_FOCUS_SCALE_MODE[] = "scale-mode";
const char QCameraParameters::KEY_QC_FOCUS_DIOPTER_MODE[] = "diopter-mode";
const char QCameraParameters::KEY_QC_ISO_PRIORITY[] = "iso-priority";
const char QCameraParameters::KEY_QC_EXP_TIME_PRIORITY[] = "exp-time-priority";
const char QCameraParameters::KEY_QC_USER_SETTING[] = "user-setting";
const char QCameraParameters::KEY_QC_WB_CCT_MODE[] = "color-temperature";
const char QCameraParameters::KEY_QC_WB_GAIN_MODE[] = "rbgb-gains";
const char QCameraParameters::KEY_QC_NOISE_REDUCTION_MODE[] = "noise-reduction-mode";
const char QCameraParameters::KEY_QC_NOISE_REDUCTION_MODE_VALUES[] = "noise-reduction-mode-values";

#ifdef TARGET_TS_MAKEUP
const char QCameraParameters::KEY_TS_MAKEUP[] = "tsmakeup";
const char QCameraParameters::KEY_TS_MAKEUP_WHITEN[] = "tsmakeup_whiten";
const char QCameraParameters::KEY_TS_MAKEUP_CLEAN[] = "tsmakeup_clean";
#endif

//KEY to share HFR batch size with video encoder.
const char QCameraParameters::KEY_QC_VIDEO_BATCH_SIZE[] = "video-batch-size";

static const char* portrait = "portrait";
static const char* landscape = "landscape";

const cam_dimension_t QCameraParameters::THUMBNAIL_SIZES_MAP[] = {
    { 256, 154 }, //1.66233
    { 240, 160 }, //1.5
    { 320, 320 }, //1.0
    { 320, 240 }, //1.33333
    { 256, 144 }, //1.777778
    { 240, 144 }, //1.666667
    { 176, 144 }, //1.222222
    /*Thumbnail sizes to match portrait picture size aspect ratio*/
    { 240, 320 }, //to match 480X640 & 240X320 picture size
    { 144, 176 }, //to match 144X176  picture size
    { 0, 0 }      // required by Android SDK
};

const QCameraParameters::QCameraMap<cam_auto_exposure_mode_type>
        QCameraParameters::AUTO_EXPOSURE_MAP[] = {
    { AUTO_EXPOSURE_FRAME_AVG,           CAM_AEC_MODE_FRAME_AVERAGE },
    { AUTO_EXPOSURE_CENTER_WEIGHTED,     CAM_AEC_MODE_CENTER_WEIGHTED },
    { AUTO_EXPOSURE_SPOT_METERING,       CAM_AEC_MODE_SPOT_METERING },
    { AUTO_EXPOSURE_SMART_METERING,      CAM_AEC_MODE_SMART_METERING },
    { AUTO_EXPOSURE_USER_METERING,       CAM_AEC_MODE_USER_METERING },
    { AUTO_EXPOSURE_SPOT_METERING_ADV,   CAM_AEC_MODE_SPOT_METERING_ADV },
    { AUTO_EXPOSURE_CENTER_WEIGHTED_ADV, CAM_AEC_MODE_CENTER_WEIGHTED_ADV },
};

const QCameraParameters::QCameraMap<cam_aec_convergence_type>
        QCameraParameters::INSTANT_AEC_MODES_MAP[] = {
    { KEY_QC_INSTANT_AEC_DISABLE,        CAM_AEC_NORMAL_CONVERGENCE },
    { KEY_QC_INSTANT_AEC_AGGRESSIVE_AEC, CAM_AEC_AGGRESSIVE_CONVERGENCE },
    { KEY_QC_INSTANT_AEC_FAST_AEC,       CAM_AEC_FAST_CONVERGENCE },
};

const QCameraParameters::QCameraMap<cam_aec_convergence_type>
        QCameraParameters::INSTANT_CAPTURE_MODES_MAP[] = {
    { KEY_QC_INSTANT_CAPTURE_DISABLE,        CAM_AEC_NORMAL_CONVERGENCE },
    { KEY_QC_INSTANT_CAPTURE_AGGRESSIVE_AEC, CAM_AEC_AGGRESSIVE_CONVERGENCE },
    { KEY_QC_INSTANT_CAPTURE_FAST_AEC,       CAM_AEC_FAST_CONVERGENCE },
};

const QCameraParameters::QCameraMap<cam_led_calibration_mode_t>
        QCameraParameters::LED_CALIBRATION_MODE_MAP[] = {
    {KEY_QC_LED_CALIBRATION_OFF,        CAM_LED_CALIBRATION_MODE_OFF},
    {KEY_QC_LED_CALIBRATION_DUAL,       CAM_LED_CALIBRATION_MODE_DUAL},
    {KEY_QC_LED_CALIBRATION_SINGLE,     CAM_LED_CALIBRATION_MODE_SINGLE},
};

const QCameraParameters::QCameraMap<cam_format_t>
        QCameraParameters::PREVIEW_FORMATS_MAP[] = {
    {PIXEL_FORMAT_YUV420SP,        CAM_FORMAT_YUV_420_NV21},
    {PIXEL_FORMAT_YUV420P,         CAM_FORMAT_YUV_420_YV12},
    {PIXEL_FORMAT_YUV420SP_ADRENO, CAM_FORMAT_YUV_420_NV21_ADRENO},
    {PIXEL_FORMAT_YV12,            CAM_FORMAT_YUV_420_YV12},
    {PIXEL_FORMAT_NV12,            CAM_FORMAT_YUV_420_NV12},
    {QC_PIXEL_FORMAT_NV12_VENUS,   CAM_FORMAT_YUV_420_NV12_VENUS}
};

const QCameraParameters::QCameraMap<cam_format_t>
        QCameraParameters::PICTURE_TYPES_MAP[] = {
    {PIXEL_FORMAT_JPEG,                          CAM_FORMAT_JPEG},
    {PIXEL_FORMAT_YUV420SP,                      CAM_FORMAT_YUV_420_NV21},
    {PIXEL_FORMAT_YUV422SP,                      CAM_FORMAT_YUV_422_NV16},
    {QC_PIXEL_FORMAT_YUV_RAW_8BIT_YUYV,          CAM_FORMAT_YUV_RAW_8BIT_YUYV},
    {QC_PIXEL_FORMAT_YUV_RAW_8BIT_YVYU,          CAM_FORMAT_YUV_RAW_8BIT_YVYU},
    {QC_PIXEL_FORMAT_YUV_RAW_8BIT_UYVY,          CAM_FORMAT_YUV_RAW_8BIT_UYVY},
    {QC_PIXEL_FORMAT_YUV_RAW_8BIT_VYUY,          CAM_FORMAT_YUV_RAW_8BIT_VYUY},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_8GBRG,       CAM_FORMAT_BAYER_QCOM_RAW_8BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_8GRBG,       CAM_FORMAT_BAYER_QCOM_RAW_8BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_8RGGB,       CAM_FORMAT_BAYER_QCOM_RAW_8BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_8BGGR,       CAM_FORMAT_BAYER_QCOM_RAW_8BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_10GBRG,      CAM_FORMAT_BAYER_QCOM_RAW_10BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_10GRBG,      CAM_FORMAT_BAYER_QCOM_RAW_10BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_10RGGB,      CAM_FORMAT_BAYER_QCOM_RAW_10BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_10BGGR,      CAM_FORMAT_BAYER_QCOM_RAW_10BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_12GBRG,      CAM_FORMAT_BAYER_QCOM_RAW_12BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_12GRBG,      CAM_FORMAT_BAYER_QCOM_RAW_12BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_12RGGB,      CAM_FORMAT_BAYER_QCOM_RAW_12BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_12BGGR,      CAM_FORMAT_BAYER_QCOM_RAW_12BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_14GBRG,      CAM_FORMAT_BAYER_QCOM_RAW_14BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_14GRBG,      CAM_FORMAT_BAYER_QCOM_RAW_14BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_14RGGB,      CAM_FORMAT_BAYER_QCOM_RAW_14BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_QCOM_RAW_14BGGR,      CAM_FORMAT_BAYER_QCOM_RAW_14BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_8GBRG,       CAM_FORMAT_BAYER_MIPI_RAW_8BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_8GRBG,       CAM_FORMAT_BAYER_MIPI_RAW_8BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_8RGGB,       CAM_FORMAT_BAYER_MIPI_RAW_8BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_8BGGR,       CAM_FORMAT_BAYER_MIPI_RAW_8BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_10GBRG,      CAM_FORMAT_BAYER_MIPI_RAW_10BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_10GRBG,      CAM_FORMAT_BAYER_MIPI_RAW_10BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_10RGGB,      CAM_FORMAT_BAYER_MIPI_RAW_10BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_10BGGR,      CAM_FORMAT_BAYER_MIPI_RAW_10BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_12GBRG,      CAM_FORMAT_BAYER_MIPI_RAW_12BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_12GRBG,      CAM_FORMAT_BAYER_MIPI_RAW_12BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_12RGGB,      CAM_FORMAT_BAYER_MIPI_RAW_12BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_12BGGR,      CAM_FORMAT_BAYER_MIPI_RAW_12BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_14GBRG,      CAM_FORMAT_BAYER_MIPI_RAW_14BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_14GRBG,      CAM_FORMAT_BAYER_MIPI_RAW_14BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_14RGGB,      CAM_FORMAT_BAYER_MIPI_RAW_14BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_MIPI_RAW_14BGGR,      CAM_FORMAT_BAYER_MIPI_RAW_14BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_8GBRG,     CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_8BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_8GRBG,     CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_8BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_8RGGB,     CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_8BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_8BGGR,     CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_8BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_10GBRG,    CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_10BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_10GRBG,    CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_10BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_10RGGB,    CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_10BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_10BGGR,    CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_10BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_12GBRG,    CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_12BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_12GRBG,    CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_12BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_12RGGB,    CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_12BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_12BGGR,    CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_12BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_14GBRG,    CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_14BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_14GRBG,    CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_14BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_14RGGB,    CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_14BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_14BGGR,    CAM_FORMAT_BAYER_IDEAL_RAW_QCOM_14BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_8GBRG,     CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_8BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_8GRBG,     CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_8BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_8RGGB,     CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_8BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_8BGGR,     CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_8BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_10GBRG,    CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_10BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_10GRBG,    CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_10BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_10RGGB,    CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_10BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_10BGGR,    CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_10BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_12GBRG,    CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_12BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_12GRBG,    CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_12BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_12RGGB,    CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_12BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_12BGGR,    CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_12BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_14GBRG,    CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_14BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_14GRBG,    CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_14BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_14RGGB,    CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_14BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_14BGGR,    CAM_FORMAT_BAYER_IDEAL_RAW_MIPI_14BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN8_8GBRG,   CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN8_8BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN8_8GRBG,   CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN8_8BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN8_8RGGB,   CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN8_8BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN8_8BGGR,   CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN8_8BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_8GBRG,  CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_8BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_8GRBG,  CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_8BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_8RGGB,  CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_8BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_8BGGR,  CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_8BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_10GBRG, CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_10BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_10GRBG, CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_10BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_10RGGB, CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_10BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_10BGGR, CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_10BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_12GBRG, CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_12BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_12GRBG, CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_12BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_12RGGB, CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_12BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_12BGGR, CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_12BPP_BGGR},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_14GBRG, CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_14BPP_GBRG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_14GRBG, CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_14BPP_GRBG},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_14RGGB, CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_14BPP_RGGB},
    {QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_14BGGR, CAM_FORMAT_BAYER_IDEAL_RAW_PLAIN16_14BPP_BGGR}
};

const QCameraParameters::QCameraMap<cam_focus_mode_type>
        QCameraParameters::FOCUS_MODES_MAP[] = {
    { FOCUS_MODE_AUTO,               CAM_FOCUS_MODE_AUTO },
    { FOCUS_MODE_INFINITY,           CAM_FOCUS_MODE_INFINITY },
    { FOCUS_MODE_MACRO,              CAM_FOCUS_MODE_MACRO },
    { FOCUS_MODE_FIXED,              CAM_FOCUS_MODE_FIXED },
    { FOCUS_MODE_EDOF,               CAM_FOCUS_MODE_EDOF },
    { FOCUS_MODE_CONTINUOUS_PICTURE, CAM_FOCUS_MODE_CONTINOUS_PICTURE },
    { FOCUS_MODE_CONTINUOUS_VIDEO,   CAM_FOCUS_MODE_CONTINOUS_VIDEO },
    { FOCUS_MODE_MANUAL_POSITION,    CAM_FOCUS_MODE_MANUAL},
};

const QCameraParameters::QCameraMap<cam_effect_mode_type>
        QCameraParameters::EFFECT_MODES_MAP[] = {
    { EFFECT_NONE,       CAM_EFFECT_MODE_OFF },
    { EFFECT_MONO,       CAM_EFFECT_MODE_MONO },
    { EFFECT_NEGATIVE,   CAM_EFFECT_MODE_NEGATIVE },
    { EFFECT_SOLARIZE,   CAM_EFFECT_MODE_SOLARIZE },
    { EFFECT_SEPIA,      CAM_EFFECT_MODE_SEPIA },
    { EFFECT_POSTERIZE,  CAM_EFFECT_MODE_POSTERIZE },
    { EFFECT_WHITEBOARD, CAM_EFFECT_MODE_WHITEBOARD },
    { EFFECT_BLACKBOARD, CAM_EFFECT_MODE_BLACKBOARD },
    { EFFECT_AQUA,       CAM_EFFECT_MODE_AQUA },
    { EFFECT_EMBOSS,     CAM_EFFECT_MODE_EMBOSS },
    { EFFECT_SKETCH,     CAM_EFFECT_MODE_SKETCH },
    { EFFECT_NEON,       CAM_EFFECT_MODE_NEON },
    { EFFECT_BEAUTY,     CAM_EFFECT_MODE_BEAUTY }
};

const QCameraParameters::QCameraMap<cam_scene_mode_type>
        QCameraParameters::SCENE_MODES_MAP[] = {
    { SCENE_MODE_AUTO,           CAM_SCENE_MODE_OFF },
    { SCENE_MODE_ACTION,         CAM_SCENE_MODE_ACTION },
    { SCENE_MODE_PORTRAIT,       CAM_SCENE_MODE_PORTRAIT },
    { SCENE_MODE_LANDSCAPE,      CAM_SCENE_MODE_LANDSCAPE },
    { SCENE_MODE_NIGHT,          CAM_SCENE_MODE_NIGHT },
    { SCENE_MODE_NIGHT_PORTRAIT, CAM_SCENE_MODE_NIGHT_PORTRAIT },
    { SCENE_MODE_THEATRE,        CAM_SCENE_MODE_THEATRE },
    { SCENE_MODE_BEACH,          CAM_SCENE_MODE_BEACH },
    { SCENE_MODE_SNOW,           CAM_SCENE_MODE_SNOW },
    { SCENE_MODE_SUNSET,         CAM_SCENE_MODE_SUNSET },
    { SCENE_MODE_STEADYPHOTO,    CAM_SCENE_MODE_ANTISHAKE },
    { SCENE_MODE_FIREWORKS ,     CAM_SCENE_MODE_FIREWORKS },
    { SCENE_MODE_SPORTS ,        CAM_SCENE_MODE_SPORTS },
    { SCENE_MODE_PARTY,          CAM_SCENE_MODE_PARTY },
    { SCENE_MODE_CANDLELIGHT,    CAM_SCENE_MODE_CANDLELIGHT },
    { SCENE_MODE_ASD,            CAM_SCENE_MODE_AUTO },
    { SCENE_MODE_BACKLIGHT,      CAM_SCENE_MODE_BACKLIGHT },
    { SCENE_MODE_FLOWERS,        CAM_SCENE_MODE_FLOWERS },
    { SCENE_MODE_AR,             CAM_SCENE_MODE_AR },
    { SCENE_MODE_HDR,            CAM_SCENE_MODE_HDR },
};

const QCameraParameters::QCameraMap<cam_flash_mode_t>
        QCameraParameters::FLASH_MODES_MAP[] = {
    { FLASH_MODE_OFF,   CAM_FLASH_MODE_OFF },
    { FLASH_MODE_AUTO,  CAM_FLASH_MODE_AUTO },
    { FLASH_MODE_ON,    CAM_FLASH_MODE_ON },
    { FLASH_MODE_TORCH, CAM_FLASH_MODE_TORCH }
};

const QCameraParameters::QCameraMap<cam_focus_algorithm_type>
         QCameraParameters::FOCUS_ALGO_MAP[] = {
    { FOCUS_ALGO_AUTO,            CAM_FOCUS_ALGO_AUTO },
    { FOCUS_ALGO_SPOT_METERING,   CAM_FOCUS_ALGO_SPOT },
    { FOCUS_ALGO_CENTER_WEIGHTED, CAM_FOCUS_ALGO_CENTER_WEIGHTED },
    { FOCUS_ALGO_FRAME_AVERAGE,   CAM_FOCUS_ALGO_AVERAGE }
};

const QCameraParameters::QCameraMap<cam_wb_mode_type>
        QCameraParameters::WHITE_BALANCE_MODES_MAP[] = {
    { WHITE_BALANCE_AUTO,            CAM_WB_MODE_AUTO },
    { WHITE_BALANCE_INCANDESCENT,    CAM_WB_MODE_INCANDESCENT },
    { WHITE_BALANCE_FLUORESCENT,     CAM_WB_MODE_FLUORESCENT },
    { WHITE_BALANCE_WARM_FLUORESCENT,CAM_WB_MODE_WARM_FLUORESCENT},
    { WHITE_BALANCE_DAYLIGHT,        CAM_WB_MODE_DAYLIGHT },
    { WHITE_BALANCE_CLOUDY_DAYLIGHT, CAM_WB_MODE_CLOUDY_DAYLIGHT },
    { WHITE_BALANCE_TWILIGHT,        CAM_WB_MODE_TWILIGHT },
    { WHITE_BALANCE_SHADE,           CAM_WB_MODE_SHADE },
    { WHITE_BALANCE_MANUAL,          CAM_WB_MODE_MANUAL},
};

const QCameraParameters::QCameraMap<cam_antibanding_mode_type>
        QCameraParameters::ANTIBANDING_MODES_MAP[] = {
    { ANTIBANDING_OFF,  CAM_ANTIBANDING_MODE_OFF },
    { ANTIBANDING_50HZ, CAM_ANTIBANDING_MODE_50HZ },
    { ANTIBANDING_60HZ, CAM_ANTIBANDING_MODE_60HZ },
    { ANTIBANDING_AUTO, CAM_ANTIBANDING_MODE_AUTO }
};

const QCameraParameters::QCameraMap<cam_iso_mode_type>
        QCameraParameters::ISO_MODES_MAP[] = {
    { ISO_AUTO,  CAM_ISO_MODE_AUTO },
    { ISO_HJR,   CAM_ISO_MODE_DEBLUR },
    { ISO_100,   CAM_ISO_MODE_100 },
    { ISO_200,   CAM_ISO_MODE_200 },
    { ISO_400,   CAM_ISO_MODE_400 },
    { ISO_800,   CAM_ISO_MODE_800 },
    { ISO_1600,  CAM_ISO_MODE_1600 },
    { ISO_3200,  CAM_ISO_MODE_3200 }
};

const QCameraParameters::QCameraMap<cam_hfr_mode_t>
        QCameraParameters::HFR_MODES_MAP[] = {
    { VIDEO_HFR_OFF, CAM_HFR_MODE_OFF },
    { VIDEO_HFR_2X, CAM_HFR_MODE_60FPS },
    { VIDEO_HFR_3X, CAM_HFR_MODE_90FPS },
    { VIDEO_HFR_4X, CAM_HFR_MODE_120FPS },
    { VIDEO_HFR_5X, CAM_HFR_MODE_150FPS },
    { VIDEO_HFR_6X, CAM_HFR_MODE_180FPS },
    { VIDEO_HFR_7X, CAM_HFR_MODE_210FPS },
    { VIDEO_HFR_8X, CAM_HFR_MODE_240FPS },
    { VIDEO_HFR_9X, CAM_HFR_MODE_480FPS }
};

const QCameraParameters::QCameraMap<cam_bracket_mode>
        QCameraParameters::BRACKETING_MODES_MAP[] = {
    { AE_BRACKET_OFF, CAM_EXP_BRACKETING_OFF },
    { AE_BRACKET,     CAM_EXP_BRACKETING_ON }
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::ON_OFF_MODES_MAP[] = {
    { VALUE_OFF, 0 },
    { VALUE_ON,  1 }
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::TOUCH_AF_AEC_MODES_MAP[] = {
    { QCameraParameters::TOUCH_AF_AEC_OFF, 0 },
    { QCameraParameters::TOUCH_AF_AEC_ON, 1 }
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::ENABLE_DISABLE_MODES_MAP[] = {
    { VALUE_ENABLE,  1 },
    { VALUE_DISABLE, 0 }
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::DENOISE_ON_OFF_MODES_MAP[] = {
    { DENOISE_OFF, 0 },
    { DENOISE_ON,  1 }
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::TRUE_FALSE_MODES_MAP[] = {
    { VALUE_FALSE, 0},
    { VALUE_TRUE,  1}
};

const QCameraParameters::QCameraMap<cam_flip_t>
        QCameraParameters::FLIP_MODES_MAP[] = {
    {FLIP_MODE_OFF, FLIP_NONE},
    {FLIP_MODE_V, FLIP_V},
    {FLIP_MODE_H, FLIP_H},
    {FLIP_MODE_VH, FLIP_V_H}
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::AF_BRACKETING_MODES_MAP[] = {
    { AF_BRACKET_OFF, 0 },
    { AF_BRACKET_ON,  1 }
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::RE_FOCUS_MODES_MAP[] = {
    { RE_FOCUS_OFF, 0 },
    { RE_FOCUS_ON,  1 }
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::CHROMA_FLASH_MODES_MAP[] = {
    { CHROMA_FLASH_OFF, 0 },
    { CHROMA_FLASH_ON,  1 }
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::OPTI_ZOOM_MODES_MAP[] = {
    { OPTI_ZOOM_OFF, 0 },
    { OPTI_ZOOM_ON,  1 }
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::TRUE_PORTRAIT_MODES_MAP[] = {
    { TRUE_PORTRAIT_OFF, 0 },
    { TRUE_PORTRAIT_ON,  1 }
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::STILL_MORE_MODES_MAP[] = {
    { STILL_MORE_OFF, 0 },
    { STILL_MORE_ON,  1 }
};

const QCameraParameters::QCameraMap<cam_cds_mode_type_t>
        QCameraParameters::CDS_MODES_MAP[] = {
    { CDS_MODE_OFF, CAM_CDS_MODE_OFF },
    { CDS_MODE_ON, CAM_CDS_MODE_ON },
    { CDS_MODE_AUTO, CAM_CDS_MODE_AUTO}
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::HDR_MODES_MAP[] = {
    { HDR_MODE_SENSOR, 0 },
    { HDR_MODE_MULTI_FRAME, 1 }
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::VIDEO_ROTATION_MODES_MAP[] = {
    { VIDEO_ROTATION_0, 0 },
    { VIDEO_ROTATION_90, 90 },
    { VIDEO_ROTATION_180, 180 },
    { VIDEO_ROTATION_270, 270 }
};

const QCameraParameters::QCameraMap<int>
        QCameraParameters::NOISE_REDUCTION_MODES_MAP[] = {
    { VALUE_OFF, 0 },
    { VALUE_FAST,  1 },
    { VALUE_HIGH_QUALITY,  2 }
};

#define DEFAULT_CAMERA_AREA "(0, 0, 0, 0, 0)"
#define DATA_PTR(MEM_OBJ,INDEX) MEM_OBJ->getPtr( INDEX )
#define TOTAL_RAM_SIZE_512MB 536870912
#define PARAM_MAP_SIZE(MAP) (sizeof(MAP)/sizeof(MAP[0]))

/*===========================================================================
 * FUNCTION   : isOEMFeat1PropEnabled
 *
 * DESCRIPTION: inline function to check from property if custom feature
 *            is enabled
 *
 * PARAMETERS : none
 *
 * RETURN     : boolean true/false
 *==========================================================================*/
static inline bool isOEMFeat1PropEnabled()
{
    char value[PROPERTY_VALUE_MAX];
    property_get("persist.camera.imglib.oemfeat1", value, "0");
    return atoi(value) > 0 ? true : false;
}

/*===========================================================================
 * FUNCTION   : QCameraParameters
 *
 * DESCRIPTION: default constructor of QCameraParameters
 *
 * PARAMETERS : none
 *
 * RETURN     : None
 *==========================================================================*/
QCameraParameters::QCameraParameters()
    : CameraParameters(),
      m_reprocScaleParam(),
      mCommon(),
      m_pCapability(NULL),
      m_pCamOpsTbl(NULL),
      m_pParamHeap(NULL),
      m_pParamBuf(NULL),
      m_pRelCamSyncHeap(NULL),
      m_pRelCamSyncBuf(NULL),
      m_bFrameSyncEnabled(false),
      mIsTypeVideo(IS_TYPE_NONE),
      mIsTypePreview(IS_TYPE_NONE),
      m_bZslMode(false),
      m_bZslMode_new(false),
      m_bForceZslMode(false),
      m_bRecordingHint(false),
      m_bRecordingHint_new(false),
      m_bHistogramEnabled(false),
      m_bLongshotEnabled(false),
      m_nFaceProcMask(0),
      m_bFaceDetectionOn(0),
      m_bDebugFps(false),
      mFocusMode(CAM_FOCUS_MODE_MAX),
      mPreviewFormat(CAM_FORMAT_YUV_420_NV21),
      mAppPreviewFormat(CAM_FORMAT_YUV_420_NV21),
      mPictureFormat(CAM_FORMAT_JPEG),
      m_bNeedRestart(false),
      m_bNoDisplayMode(false),
      m_bWNROn(false),
      m_bTNRPreviewOn(false),
      m_bTNRVideoOn(false),
      m_bTNRSnapshotOn(false),
      m_bInited(false),
      m_nRetroBurstNum(0),
      m_nBurstLEDOnPeriod(100),
      m_bUpdateEffects(false),
      m_bSceneTransitionAuto(false),
      m_bPreviewFlipChanged(false),
      m_bVideoFlipChanged(false),
      m_bSnapshotFlipChanged(false),
      m_bFixedFrameRateSet(false),
      m_bHDREnabled(false),
      m_bLocalHDREnabled(false),
      m_bAVTimerEnabled(false),
      m_bDISEnabled(false),
      m_bMetaRawEnabled(false),
      m_MobiMask(0),
      m_AdjustFPS(NULL),
      m_bHDR1xFrameEnabled(false),
      m_HDRSceneEnabled(false),
      m_bHDRThumbnailProcessNeeded(false),
      m_bHDR1xExtraBufferNeeded(true),
      m_bHDROutputCropEnabled(false),
      m_tempMap(),
      m_bAFBracketingOn(false),
      m_bReFocusOn(false),
      m_bChromaFlashOn(false),
      m_bOptiZoomOn(false),
      m_bSceneSelection(false),
      m_SelectedScene(CAM_SCENE_MODE_MAX),
      m_bSeeMoreOn(false),
      m_bStillMoreOn(false),
      m_bHighQualityNoiseReductionMode(false),
      m_bHfrMode(false),
      m_bSensorHDREnabled(false),
      m_bRdiMode(false),
      m_bSecureMode(false),
      m_bAeBracketingEnabled(false),
      mFlashValue(CAM_FLASH_MODE_OFF),
      mFlashDaemonValue(CAM_FLASH_MODE_OFF),
      mHfrMode(CAM_HFR_MODE_OFF),
      m_bHDRModeSensor(true),
      mOfflineRAW(false),
      m_bTruePortraitOn(false),
      m_bIsLowMemoryDevice(false),
      mCds_mode(CAM_CDS_MODE_OFF),
      m_LLCaptureEnabled(FALSE),
      m_LowLightLevel(CAM_LOW_LIGHT_OFF),
      m_bLtmForSeeMoreEnabled(false),
      m_expTime(0),
      m_isoValue(0),
      m_ManualCaptureMode(CAM_MANUAL_CAPTURE_TYPE_OFF),
      m_ledCalibrationMode(CAM_LED_CALIBRATION_MODE_OFF),
      m_bInstantAEC(false),
      m_bInstantCapture(false),
      mAecFrameBound(0),
      mAecSkipDisplayFrameBound(0),
      m_bQuadraCfa(false),
      m_bSmallJpegSize(false)
{
    char value[PROPERTY_VALUE_MAX];
    // TODO: may move to parameter instead of sysprop
    property_get("persist.debug.sf.showfps", value, "0");
    m_bDebugFps = atoi(value) > 0 ? true : false;

    // For thermal mode, it should be set as system property
    // because system property applies to all applications, while
    // parameters only apply to specific app.
    property_get("persist.camera.thermal.mode", value, "fps");
    if (!strcmp(value, "frameskip")) {
        m_ThermalMode = QCAMERA_THERMAL_ADJUST_FRAMESKIP;
    } else {
        if (strcmp(value, "fps"))
            LOGW("Invalid camera thermal mode %s", value);
        m_ThermalMode = QCAMERA_THERMAL_ADJUST_FPS;
    }

    memset(value, 0, sizeof(value));
    // As per Power/Quality evaluation, LTM is enabled by default in SeeMore/StillMore usecase
    // to improve the quality as there is no much impact to power
    property_get("persist.camera.ltmforseemore", value, "1");
    m_bLtmForSeeMoreEnabled = atoi(value);

    memset(&m_LiveSnapshotSize, 0, sizeof(m_LiveSnapshotSize));
    memset(&m_default_fps_range, 0, sizeof(m_default_fps_range));
    memset(&m_hfrFpsRange, 0, sizeof(m_hfrFpsRange));
    memset(&m_stillmore_config, 0, sizeof(cam_still_more_t));
    memset(&m_captureFrameConfig, 0, sizeof(cam_capture_frame_config_t));
    memset(&m_relCamSyncInfo, 0, sizeof(cam_sync_related_sensors_event_info_t));
    mTotalPPCount = 1;
    mZoomLevel = 0;
    mParmZoomLevel = 0;
    mCurPPCount = 0;
    mBufBatchCnt = 0;
    mRotation = 0;
    mJpegRotation = 0;
    mVideoBatchSize = 0;
    m_bOEMFeatEnabled = isOEMFeat1PropEnabled();
}

/*===========================================================================
 * FUNCTION   : QCameraParameters
 *
 * DESCRIPTION: constructor of QCameraParameters
 *
 * PARAMETERS :
 *   @params  : parameters in string
 *
 * RETURN     : None
 *==========================================================================*/
QCameraParameters::QCameraParameters(const String8 &params)
    : CameraParameters(params),
    m_reprocScaleParam(),
    m_pCapability(NULL),
    m_pCamOpsTbl(NULL),
    m_pParamHeap(NULL),
    m_pParamBuf(NULL),
    m_pRelCamSyncHeap(NULL),
    m_pRelCamSyncBuf(NULL),
    m_bFrameSyncEnabled(false),
    m_bZslMode(false),
    m_bZslMode_new(false),
    m_bForceZslMode(false),
    m_bRecordingHint(false),
    m_bRecordingHint_new(false),
    m_bHistogramEnabled(false),
    m_bLongshotEnabled(false),
    m_nFaceProcMask(0),
    m_bDebugFps(false),
    mFocusMode(CAM_FOCUS_MODE_MAX),
    mPreviewFormat(CAM_FORMAT_YUV_420_NV21),
    mAppPreviewFormat(CAM_FORMAT_YUV_420_NV21),
    mPictureFormat(CAM_FORMAT_JPEG),
    m_bNeedRestart(false),
    m_bNoDisplayMode(false),
    m_bWNROn(false),
    m_bTNRPreviewOn(false),
    m_bTNRVideoOn(false),
    m_bTNRSnapshotOn(false),
    m_bInited(false),
    m_nRetroBurstNum(0),
    m_nBurstLEDOnPeriod(100),
    m_bPreviewFlipChanged(false),
    m_bVideoFlipChanged(false),
    m_bSnapshotFlipChanged(false),
    m_bFixedFrameRateSet(false),
    m_bHDREnabled(false),
    m_bLocalHDREnabled(false),
    m_bAVTimerEnabled(false),
    m_AdjustFPS(NULL),
    m_bHDR1xFrameEnabled(false),
    m_HDRSceneEnabled(false),
    m_bHDRThumbnailProcessNeeded(false),
    m_bHDR1xExtraBufferNeeded(true),
    m_bHDROutputCropEnabled(false),
    m_tempMap(),
    m_bAFBracketingOn(false),
    m_bReFocusOn(false),
    m_bChromaFlashOn(false),
    m_bOptiZoomOn(false),
    m_bSceneSelection(false),
    m_SelectedScene(CAM_SCENE_MODE_MAX),
    m_bSeeMoreOn(false),
    m_bStillMoreOn(false),
    m_bHighQualityNoiseReductionMode(false),
    m_bHfrMode(false),
    m_bSensorHDREnabled(false),
    m_bRdiMode(false),
    m_bSecureMode(false),
    m_bAeBracketingEnabled(false),
    mFlashValue(CAM_FLASH_MODE_OFF),
    mFlashDaemonValue(CAM_FLASH_MODE_OFF),
    mHfrMode(CAM_HFR_MODE_OFF),
    m_bHDRModeSensor(true),
    mOfflineRAW(false),
    m_bTruePortraitOn(false),
    m_bIsLowMemoryDevice(false),
    mCds_mode(CAM_CDS_MODE_OFF),
    mParmEffect(CAM_EFFECT_MODE_OFF),
    m_LLCaptureEnabled(FALSE),
    m_LowLightLevel(CAM_LOW_LIGHT_OFF),
    m_bLtmForSeeMoreEnabled(false),
    m_expTime(0),
    m_isoValue(0),
    m_ManualCaptureMode(CAM_MANUAL_CAPTURE_TYPE_OFF),
    m_ledCalibrationMode(CAM_LED_CALIBRATION_MODE_OFF),
    m_bInstantAEC(false),
    m_bInstantCapture(false),
    mAecFrameBound(0),
    mAecSkipDisplayFrameBound(0),
    m_bQuadraCfa(false),
    m_bSmallJpegSize(false)
{
    memset(&m_LiveSnapshotSize, 0, sizeof(m_LiveSnapshotSize));
    memset(&m_default_fps_range, 0, sizeof(m_default_fps_range));
    memset(&m_hfrFpsRange, 0, sizeof(m_hfrFpsRange));
    memset(&m_stillmore_config, 0, sizeof(cam_still_more_t));
    memset(&m_relCamSyncInfo, 0, sizeof(cam_sync_related_sensors_event_info_t));
    mTotalPPCount = 0;
    mZoomLevel = 0;
    mParmZoomLevel = 0;
    mCurPPCount = 0;
    mRotation = 0;
    mJpegRotation = 0;
    mBufBatchCnt = 0;
    mVideoBatchSize = 0;
    m_bOEMFeatEnabled = isOEMFeat1PropEnabled();
}

/*===========================================================================
 * FUNCTION   : ~QCameraParameters
 *
 * DESCRIPTION: deconstructor of QCameraParameters
 *
 * PARAMETERS : none
 *
 * RETURN     : None
 *==========================================================================*/
QCameraParameters::~QCameraParameters()
{
    deinit();
}

/*===========================================================================
 * FUNCTION   : createSizesString
 *
 * DESCRIPTION: create string obj contains array of dimensions
 *
 * PARAMETERS :
 *   @sizes   : array of dimensions
 *   @len     : size of dimension array
 *
 * RETURN     : string obj
 *==========================================================================*/
String8 QCameraParameters::createSizesString(const cam_dimension_t *sizes, size_t len)
{
    String8 str;
    char buffer[32];

    if (len > 0) {
        snprintf(buffer, sizeof(buffer), "%dx%d", sizes[0].width, sizes[0].height);
        str.append(buffer);
    }
    for (size_t i = 1; i < len; i++) {
        snprintf(buffer, sizeof(buffer), ",%dx%d",
                sizes[i].width, sizes[i].height);
        str.append(buffer);
    }
    return str;
}

/*===========================================================================
 * FUNCTION   : createValuesString
 *
 * DESCRIPTION: create string obj contains array of values from map when matched
 *              from input values array
 *
 * PARAMETERS :
 *   @values  : array of values
 *   @len     : size of values array
 *   @map     : map contains the mapping between values and enums
 *   @map_len : size of the map
 *
 * RETURN     : string obj
 *==========================================================================*/
template <typename valuesType, class mapType> String8 createValuesString(
        const valuesType *values, size_t len, const mapType *map, size_t map_len)
{
    String8 str;
    int count = 0;

    for (size_t i = 0; i < len; i++ ) {
        for (size_t j = 0; j < map_len; j ++)
            if (map[j].val == values[i]) {
                if (NULL != map[j].desc) {
                    if (count > 0) {
                        str.append(",");
                    }
                    str.append(map[j].desc);
                    count++;
                    break; //loop j
                }
            }
    }
    return str;
}

/*===========================================================================
 * FUNCTION   : createValuesStringFromMap
 *
 * DESCRIPTION: create string obj contains array of values directly from map
 *
 * PARAMETERS :
 *   @map     : map contains the mapping between values and enums
 *   @map_len : size of the map
 *
 * RETURN     : string obj
 *==========================================================================*/
template <class mapType> String8 createValuesStringFromMap(
        const mapType *map, size_t map_len)
{
    String8 str;

    for (size_t i = 0; i < map_len; i++) {
        if (NULL != map[i].desc) {
            if (i > 0) {
                str.append(",");
            }
            str.append(map[i].desc);
        }
    }
    return str;
}

/*===========================================================================
 * FUNCTION   : createZoomRatioValuesString
 *
 * DESCRIPTION: create string obj contains array of zoom ratio values
 *
 * PARAMETERS :
 *   @zoomRaios  : array of zoom ratios
 *   @length     : size of the array
 *
 * RETURN     : string obj
 *==========================================================================*/
String8 QCameraParameters::createZoomRatioValuesString(uint32_t *zoomRatios,
        size_t length)
{
    String8 str;
    char buffer[32] = {0};

    if(length > 0){
        snprintf(buffer, sizeof(buffer), "%d", zoomRatios[0]);
        str.append(buffer);
    }

    for (size_t i = 1; i < length; i++) {
        memset(buffer, 0, sizeof(buffer));
        snprintf(buffer, sizeof(buffer), ",%d", zoomRatios[i]);
        str.append(buffer);
    }
    return str;
}

/*===========================================================================
 * FUNCTION   : createHfrValuesString
 *
 * DESCRIPTION: create string obj contains array of hfr values from map when
 *              matched from input hfr values
 *
 * PARAMETERS :
 *   @values  : array of hfr info
 *   @len     : size of the array
 *   @map     : map of hfr string value and enum
 *   map_len  : size of map
 *
 * RETURN     : string obj
 *==========================================================================*/
String8 QCameraParameters::createHfrValuesString(const cam_hfr_info_t *values,
        size_t len, const QCameraMap<cam_hfr_mode_t> *map, size_t map_len)
{
    String8 str;
    int count = 0;

    //Create HFR supported size string.
    for (size_t i = 0; i < len; i++ ) {
        for (size_t j = 0; j < map_len; j ++) {
            if (map[j].val == (int)values[i].mode) {
                if (NULL != map[j].desc) {
                    if (count > 0) {
                        str.append(",");
                    }
                     str.append(map[j].desc);
                     count++;
                     break; //loop j
                }
            }
        }
    }
    if (count > 0) {
        str.append(",");
    }
    str.append(VIDEO_HFR_OFF);
    return str;
}

/*===========================================================================
 * FUNCTION   : createHfrSizesString
 *
 * DESCRIPTION: create string obj contains array of hfr sizes
 *
 * PARAMETERS :
 *   @values  : array of hfr info
 *   @len     : size of the array
 *
 * RETURN     : string obj
 *==========================================================================*/
String8 QCameraParameters::createHfrSizesString(const cam_hfr_info_t *values, size_t len)
{
    String8 str;
    char buffer[32];

    if (len > 0) {
        snprintf(buffer, sizeof(buffer), "%dx%d",
                 values[0].dim[0].width, values[0].dim[0].height);
        str.append(buffer);
    }
    for (size_t i = 1; i < len; i++) {
        snprintf(buffer, sizeof(buffer), ",%dx%d",
                 values[i].dim[0].width, values[i].dim[0].height);
        str.append(buffer);
    }
    return str;
}

/*===========================================================================
 * FUNCTION   : createFpsString
 *
 * DESCRIPTION: create string obj contains array of FPS rates
 *
 * PARAMETERS :
 *   @fps     : default fps range
 *
 * RETURN     : string obj
 *==========================================================================*/
String8 QCameraParameters::createFpsString(cam_fps_range_t &fps)
{
    char buffer[32];
    String8 fpsValues;

    int min_fps = int(fps.min_fps);
    int max_fps = int(fps.max_fps);

    if (min_fps < fps.min_fps){
        min_fps++;
    }
    if (max_fps > fps.max_fps) {
        max_fps--;
    }
    if (min_fps <= max_fps) {
        snprintf(buffer, sizeof(buffer), "%d", min_fps);
        fpsValues.append(buffer);
    }

    for (int i = min_fps+1; i <= max_fps; i++) {
        snprintf(buffer, sizeof(buffer), ",%d", i);
        fpsValues.append(buffer);
    }

    return fpsValues;
}

/*===========================================================================
 * FUNCTION   : createFpsRangeString
 *
 * DESCRIPTION: create string obj contains array of FPS ranges
 *
 * PARAMETERS :
 *   @fps     : array of fps ranges
 *   @len     : size of the array
 *   @default_fps_index : reference to index of default fps range
 *
 * RETURN     : string obj
 *==========================================================================*/
String8 QCameraParameters::createFpsRangeString(const cam_fps_range_t* fps,
        size_t len, int &default_fps_index)
{
    String8 str;
    char buffer[32];
    int max_range = 0;
    int min_fps, max_fps;

    if (len > 0) {
        min_fps = int(fps[0].min_fps * 1000);
        max_fps = int(fps[0].max_fps * 1000);
        max_range = max_fps - min_fps;
        default_fps_index = 0;
        snprintf(buffer, sizeof(buffer), "(%d,%d)", min_fps, max_fps);
        str.append(buffer);
    }
    for (size_t i = 1; i < len; i++) {
        min_fps = int(fps[i].min_fps * 1000);
        max_fps = int(fps[i].max_fps * 1000);
        if (max_range < (max_fps - min_fps)) {
            max_range = max_fps - min_fps;
            default_fps_index = (int)i;
        }
        snprintf(buffer, sizeof(buffer), ",(%d,%d)", min_fps, max_fps);
        str.append(buffer);
    }
    return str;
}

/*===========================================================================
 * FUNCTION   : lookupAttr
 *
 * DESCRIPTION: lookup a value by its name
 *
 * PARAMETERS :
 *   @attr    : map contains <name, value>
 *   @len     : size of the map
 *   @name    : name to be looked up
 *
 * RETURN     : valid value if found
 *              NAME_NOT_FOUND if not found
 *==========================================================================*/
template <class mapType> int lookupAttr(const mapType *arr,
        size_t len, const char *name)
{
    if (name) {
        for (size_t i = 0; i < len; i++) {
            if (!strcmp(arr[i].desc, name))
                return arr[i].val;
        }
    }
    return NAME_NOT_FOUND;
}

/*===========================================================================
 * FUNCTION   : lookupNameByValue
 *
 * DESCRIPTION: lookup a name by its value
 *
 * PARAMETERS :
 *   @attr    : map contains <name, value>
 *   @len     : size of the map
 *   @value   : value to be looked up
 *
 * RETURN     : name str or NULL if not found
 *==========================================================================*/
template <class mapType> const char *lookupNameByValue(const mapType *arr,
        size_t len, int value)
{
    for (size_t i = 0; i < len; i++) {
        if (arr[i].val == value) {
            return arr[i].desc;
        }
    }
    return NULL;
}

/*===========================================================================
 * FUNCTION   : setPreviewSize
 *
 * DESCRIPTION: set preview size from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setPreviewSize(const QCameraParameters& params)
{
    int width = 0, height = 0;
    int old_width = 0, old_height = 0;
    params.getPreviewSize(&width, &height);
    CameraParameters::getPreviewSize(&old_width, &old_height);

    // Validate the preview size
    for (size_t i = 0; i < m_pCapability->preview_sizes_tbl_cnt; ++i) {
        if (width ==  m_pCapability->preview_sizes_tbl[i].width
           && height ==  m_pCapability->preview_sizes_tbl[i].height) {
            // check if need to restart preview in case of preview size change
            if (width != old_width || height != old_height) {
                LOGI("Requested preview size %d x %d", width, height);
                m_bNeedRestart = true;
            }
            // set the new value
            CameraParameters::setPreviewSize(width, height);
            return NO_ERROR;
        }
    }
    if (m_relCamSyncInfo.mode == CAM_MODE_SECONDARY) {
        char prop[PROPERTY_VALUE_MAX];
        // set prop to configure aux preview size
        property_get("persist.camera.aux.preview.size", prop, "0");
        parse_pair(prop, &width, &height, 'x', NULL);
        bool foundMatch = false;
        for (size_t i = 0; i < m_pCapability->preview_sizes_tbl_cnt; ++i) {
            if (width ==  m_pCapability->preview_sizes_tbl[i].width &&
                    height ==  m_pCapability->preview_sizes_tbl[i].height) {
               foundMatch = true;
            }
        }
        if (!foundMatch) {
            width = m_pCapability->preview_sizes_tbl[0].width;
            height = m_pCapability->preview_sizes_tbl[0].height;
        }
        // check if need to restart preview in case of preview size change
        if (width != old_width || height != old_height) {
            m_bNeedRestart = true;
        }
        CameraParameters::setPreviewSize(width, height);
        LOGH("Secondary Camera: preview size %d x %d", width, height);
        return NO_ERROR;
    }

    LOGE("Invalid preview size requested: %dx%d", width, height);
    return BAD_VALUE;
}

/*===========================================================================
 * FUNCTION   : setPictureSize
 *
 * DESCRIPTION: set picture size from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setPictureSize(const QCameraParameters& params)
{
    int width, height;
    params.getPictureSize(&width, &height);
    int old_width, old_height;
    CameraParameters::getPictureSize(&old_width, &old_height);

    // Validate the picture size
    if(!m_reprocScaleParam.isScaleEnabled()){
        for (size_t i = 0; i < m_pCapability->picture_sizes_tbl_cnt; ++i) {
            if (width ==  m_pCapability->picture_sizes_tbl[i].width
               && height ==  m_pCapability->picture_sizes_tbl[i].height) {
                // check if need to restart preview in case of picture size change
                if ((m_bZslMode || m_bRecordingHint) &&
                    (width != old_width || height != old_height)) {
                    LOGI("Requested picture size %d x %d", width, height);
                    m_bNeedRestart = true;
                }
                // set the new value
                CameraParameters::setPictureSize(width, height);
                // Update View angles based on Picture Aspect ratio
                updateViewAngles();
                return NO_ERROR;
            }
        }
    }else{
        //should use scaled picture size table to validate
        if(m_reprocScaleParam.setValidatePicSize(width, height) == NO_ERROR){
            // check if need to restart preview in case of picture size change
            if ((m_bZslMode || m_bRecordingHint) &&
                (width != old_width || height != old_height)) {
                m_bNeedRestart = true;
            }
            // set the new value
            char val[32];
            snprintf(val, sizeof(val), "%dx%d", width, height);
            updateParamEntry(KEY_PICTURE_SIZE, val);
            LOGH("%s", val);
            // Update View angles based on Picture Aspect ratio
            updateViewAngles();
            return NO_ERROR;
        }
    }
    if (m_relCamSyncInfo.mode == CAM_MODE_SECONDARY) {
        char prop[PROPERTY_VALUE_MAX];
        // set prop to configure aux preview size
        property_get("persist.camera.aux.picture.size", prop, "0");
        parse_pair(prop, &width, &height, 'x', NULL);
        bool foundMatch = false;
        for (size_t i = 0; i < m_pCapability->picture_sizes_tbl_cnt; ++i) {
            if (width ==  m_pCapability->picture_sizes_tbl[i].width &&
                    height ==  m_pCapability->picture_sizes_tbl[i].height) {
               foundMatch = true;
            }
        }
        if (!foundMatch) {
            width = m_pCapability->picture_sizes_tbl[0].width;
            height = m_pCapability->picture_sizes_tbl[0].height;
        }
        // check if need to restart preview in case of preview size change
        if (width != old_width || height != old_height) {
            m_bNeedRestart = true;
        }
        char val[32];
        snprintf(val, sizeof(val), "%dx%d", width, height);
        set(KEY_PICTURE_SIZE, val);
        LOGH("Secondary Camera: picture size %s", val);
        return NO_ERROR;
    }
    LOGE("Invalid picture size requested: %dx%d", width, height);
    return BAD_VALUE;
}

/*===========================================================================
 * FUNCTION   : updateViewAngles
 *
 * DESCRIPTION: Update the Horizontal & Vertical based on the Aspect ratio of Preview and
 *                        Picture aspect ratio
 *
 * PARAMETERS : none
 *
 * RETURN     : none
 *==========================================================================*/
void QCameraParameters::updateViewAngles()
{
    double stillAspectRatio, maxPictureAspectRatio;
    int stillWidth, stillHeight, maxWidth, maxHeight;
    // The crop factors from the full sensor array to the still picture crop region
    double horizCropFactor = 1.f,vertCropFactor = 1.f;
    float horizViewAngle, vertViewAngle, maxHfov, maxVfov;

    // Get current Picture & max Snapshot sizes
    getPictureSize(&stillWidth, &stillHeight);
    maxWidth  = m_pCapability->picture_sizes_tbl[0].width;
    maxHeight = m_pCapability->picture_sizes_tbl[0].height;

    // Get default maximum FOV from corresponding sensor driver
    maxHfov = m_pCapability->hor_view_angle;
    maxVfov = m_pCapability->ver_view_angle;

    stillAspectRatio = (double)stillWidth/stillHeight;
    maxPictureAspectRatio = (double)maxWidth/maxHeight;
    LOGD("Stillwidth: %d, height: %d", stillWidth, stillHeight);
    LOGD("Max width: %d, height: %d", maxWidth, maxHeight);
    LOGD("still aspect: %f, Max Pic Aspect: %f",
            stillAspectRatio, maxPictureAspectRatio);

    // crop as per the Maximum Snapshot aspect ratio
    if (stillAspectRatio < maxPictureAspectRatio)
        horizCropFactor = stillAspectRatio/maxPictureAspectRatio;
    else
        vertCropFactor = maxPictureAspectRatio/stillAspectRatio;

    LOGD("horizCropFactor %f, vertCropFactor %f",
             horizCropFactor, vertCropFactor);

    // Now derive the final FOV's based on field of view formula is i.e,
    // angle of view = 2 * arctangent ( d / 2f )
    // where d is the physical sensor dimension of interest, and f is
    // the focal length. This only applies to rectilinear sensors, for focusing
    // at distances >> f, etc.
    // Here d/2f is nothing but the Maximum Horizontal or Veritical FOV
    horizViewAngle = (180/PI)*2*atan(horizCropFactor*tan((maxHfov/2)*(PI/180)));
    vertViewAngle = (180/PI)*2*atan(horizCropFactor*tan((maxVfov/2)*(PI/180)));

    setFloat(QCameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, horizViewAngle);
    setFloat(QCameraParameters::KEY_VERTICAL_VIEW_ANGLE, vertViewAngle);
    LOGH("Final horizViewAngle %f, vertViewAngle %f",
            horizViewAngle, vertViewAngle);
}

/*===========================================================================
 * FUNCTION   : setVideoSize
 *
 * DESCRIPTION: set video size from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setVideoSize(const QCameraParameters& params)
{
    const char *str= NULL;
    int width, height;
    str = params.get(KEY_VIDEO_SIZE);
    int old_width, old_height;
    CameraParameters::getVideoSize(&old_width, &old_height);
    if(!str) {
        //If application didn't set this parameter string, use the values from
        //getPreviewSize() as video dimensions.
        params.getPreviewSize(&width, &height);
        LOGW("No Record Size requested, use the preview dimensions");
    } else {
        params.getVideoSize(&width, &height);
    }

    // Validate the video size
    for (size_t i = 0; i < m_pCapability->video_sizes_tbl_cnt; ++i) {
        if (width ==  m_pCapability->video_sizes_tbl[i].width
                && height ==  m_pCapability->video_sizes_tbl[i].height) {
            // check if need to restart preview in case of video size change
            if (m_bRecordingHint &&
               (width != old_width || height != old_height)) {
                m_bNeedRestart = true;
            }

            // set the new value
            LOGH("Requested video size %d x %d", width, height);
            CameraParameters::setVideoSize(width, height);
            return NO_ERROR;
        }
    }
    if (m_relCamSyncInfo.mode == CAM_MODE_SECONDARY) {
        // Set the default preview size for secondary camera
        width = m_pCapability->video_sizes_tbl[0].width;
        height = m_pCapability->video_sizes_tbl[0].height;
        // check if need to restart preview in case of preview size change
        if (width != old_width || height != old_height) {
            m_bNeedRestart = true;
        }

        CameraParameters::setVideoSize(width, height);
        LOGH("Secondary Camera: video size %d x %d",
                 width, height);
        return NO_ERROR;
    }

    LOGE("Error !! Invalid video size requested: %dx%d", width, height);
    return BAD_VALUE;
}

/*===========================================================================
 * FUNCTION   : getLiveSnapshotSize
 *
 * DESCRIPTION: get live snapshot size
 *
 * PARAMETERS : dim - Update dim with the liveshot size
 *
 *==========================================================================*/
void QCameraParameters::getLiveSnapshotSize(cam_dimension_t &dim)
{
    if(is4k2kVideoResolution()) {
        // We support maximum 8M liveshot @4K2K video resolution
        cam_dimension_t resolution = {0, 0};
        CameraParameters::getVideoSize(&resolution.width, &resolution.height);
        if((m_LiveSnapshotSize.width > resolution.width) ||
                (m_LiveSnapshotSize.height > resolution.height)) {
            m_LiveSnapshotSize.width = resolution.width;
            m_LiveSnapshotSize.height = resolution.height;
        }
    }
    dim = m_LiveSnapshotSize;
    LOGH("w x h: %d x %d", dim.width, dim.height);
}

/*===========================================================================
 * FUNCTION   : setLiveSnapshotSize
 *
 * DESCRIPTION: set live snapshot size
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setLiveSnapshotSize(const QCameraParameters& params)
{
    char value[PROPERTY_VALUE_MAX];
    property_get("persist.camera.opt.livepic", value, "1");
    bool useOptimal = atoi(value) > 0 ? true : false;
    bool vHdrOn;
    int32_t liveSnapWidth = 0, liveSnapHeight = 0;
    // use picture size from user setting
    params.getPictureSize(&m_LiveSnapshotSize.width, &m_LiveSnapshotSize.height);

    size_t livesnapshot_sizes_tbl_cnt =
            m_pCapability->livesnapshot_sizes_tbl_cnt;
    cam_dimension_t *livesnapshot_sizes_tbl =
            &m_pCapability->livesnapshot_sizes_tbl[0];

    if(is4k2kVideoResolution()) {
        // We support maximum 8M liveshot @4K2K video resolution
        cam_dimension_t resolution = {0, 0};
        CameraParameters::getVideoSize(&resolution.width, &resolution.height);
        if((m_LiveSnapshotSize.width > resolution.width) ||
                (m_LiveSnapshotSize.height > resolution.height)) {
            m_LiveSnapshotSize.width = resolution.width;
            m_LiveSnapshotSize.height = resolution.height;
        }
    }

    // check if HFR is enabled
    const char *hfrStr = params.get(KEY_QC_VIDEO_HIGH_FRAME_RATE);
    cam_hfr_mode_t hfrMode = CAM_HFR_MODE_OFF;
    const char *hsrStr = params.get(KEY_QC_VIDEO_HIGH_SPEED_RECORDING);

    const char *vhdrStr = params.get(KEY_QC_VIDEO_HDR);
    vHdrOn = (vhdrStr != NULL && (0 == strcmp(vhdrStr,"on"))) ? true : false;
    if (vHdrOn) {
        livesnapshot_sizes_tbl_cnt = m_pCapability->vhdr_livesnapshot_sizes_tbl_cnt;
        livesnapshot_sizes_tbl = &m_pCapability->vhdr_livesnapshot_sizes_tbl[0];
    }
    if ((hsrStr != NULL) && strcmp(hsrStr, "off")) {
        int32_t hsr = lookupAttr(HFR_MODES_MAP, PARAM_MAP_SIZE(HFR_MODES_MAP), hsrStr);
        if ((hsr != NAME_NOT_FOUND) && (hsr > CAM_HFR_MODE_OFF)) {
            // if HSR is enabled, change live snapshot size
            for (size_t i = 0; i < m_pCapability->hfr_tbl_cnt; i++) {
                if (m_pCapability->hfr_tbl[i].mode == hsr) {
                    livesnapshot_sizes_tbl_cnt =
                            m_pCapability->hfr_tbl[i].livesnapshot_sizes_tbl_cnt;
                    livesnapshot_sizes_tbl =
                            &m_pCapability->hfr_tbl[i].livesnapshot_sizes_tbl[0];
                    hfrMode = m_pCapability->hfr_tbl[i].mode;
                    break;
                }
            }
        }
    } else if ((hfrStr != NULL) && strcmp(hfrStr, "off")) {
        int32_t hfr = lookupAttr(HFR_MODES_MAP, PARAM_MAP_SIZE(HFR_MODES_MAP), hfrStr);
        if ((hfr != NAME_NOT_FOUND) && (hfr > CAM_HFR_MODE_OFF)) {
            // if HFR is enabled, change live snapshot size
            for (size_t i = 0; i < m_pCapability->hfr_tbl_cnt; i++) {
                if (m_pCapability->hfr_tbl[i].mode == hfr) {
                    livesnapshot_sizes_tbl_cnt =
                            m_pCapability->hfr_tbl[i].livesnapshot_sizes_tbl_cnt;
                    livesnapshot_sizes_tbl =
                            &m_pCapability->hfr_tbl[i].livesnapshot_sizes_tbl[0];
                    hfrMode = m_pCapability->hfr_tbl[i].mode;
                    break;
                }
            }
        }
    }

    if (useOptimal || hfrMode != CAM_HFR_MODE_OFF || vHdrOn) {
        bool found = false;

        // first check if picture size is within the list of supported sizes
        for (size_t i = 0; i < livesnapshot_sizes_tbl_cnt; ++i) {
            if (m_LiveSnapshotSize.width == livesnapshot_sizes_tbl[i].width &&
                m_LiveSnapshotSize.height == livesnapshot_sizes_tbl[i].height) {
                found = true;
                break;
            }
        }

        if (!found) {
            // use optimal live snapshot size from supported list,
            // that has same preview aspect ratio
            int width = 0, height = 0;
            params.getPreviewSize(&width, &height);

            double previewAspectRatio = (double)width / height;
            for (size_t i = 0; i < livesnapshot_sizes_tbl_cnt; ++i) {
                double ratio = (double)livesnapshot_sizes_tbl[i].width /
                                livesnapshot_sizes_tbl[i].height;
                if (fabs(previewAspectRatio - ratio) <= ASPECT_TOLERANCE) {
                    m_LiveSnapshotSize = livesnapshot_sizes_tbl[i];
                    found = true;
                    break;
                }
            }

            if (!found && ((hfrMode != CAM_HFR_MODE_OFF) || vHdrOn)) {
                // Cannot find matching aspect ration from supported live snapshot list
                // choose the max dim from preview and video size
                LOGD("Cannot find matching aspect ratio, choose max of preview or video size");
                params.getVideoSize(&m_LiveSnapshotSize.width, &m_LiveSnapshotSize.height);
                if (m_LiveSnapshotSize.width < width && m_LiveSnapshotSize.height < height) {
                    m_LiveSnapshotSize.width = width;
                    m_LiveSnapshotSize.height = height;
                }
            }
        }
    }
    //To read liveshot resolution from setprop instead of matching aspect ratio.
    //The setprop resolution format should be WxH.
    //e.g: adb shell setprop persist.camera.liveshot.size 1280x720
    memset(value, 0, PROPERTY_VALUE_MAX);
    property_get("persist.camera.liveshot.size", value, "");
    if (strlen(value) > 0) {
        char *saveptr = NULL;
        char *token = strtok_r(value, "x", &saveptr);
        if (token != NULL) {
            liveSnapWidth = atoi(token);
        }
        token = strtok_r(NULL, "x", &saveptr);
        if (token != NULL) {
            liveSnapHeight = atoi(token);
        }
        if ((liveSnapWidth!=0) && (liveSnapHeight!=0)) {
            for (size_t i = 0; i < m_pCapability->picture_sizes_tbl_cnt; ++i) {
                if (liveSnapWidth ==  m_pCapability->picture_sizes_tbl[i].width
                        && liveSnapHeight ==  m_pCapability->picture_sizes_tbl[i].height) {
                   m_LiveSnapshotSize.width = liveSnapWidth;
                   m_LiveSnapshotSize.height = liveSnapHeight;
                   break;
                }
            }
        }
    }
    LOGH("live snapshot size %d x %d",
          m_LiveSnapshotSize.width, m_LiveSnapshotSize.height);

    return NO_ERROR;
}


/*===========================================================================
 * FUNCTION   : setRawSize
 *
 * DESCRIPTION: set live snapshot size
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setRawSize(cam_dimension_t &dim)
{
    m_rawSize = dim;
    return NO_ERROR;
}
/*===========================================================================
 * FUNCTION   : setPreviewFormat
 *
 * DESCRIPTION: set preview format from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setPreviewFormat(const QCameraParameters& params)
{
    const char *str = params.getPreviewFormat();
    int32_t previewFormat = lookupAttr(PREVIEW_FORMATS_MAP,
            PARAM_MAP_SIZE(PREVIEW_FORMATS_MAP), str);
    if (previewFormat != NAME_NOT_FOUND) {
        if (isUBWCEnabled()) {
            char prop[PROPERTY_VALUE_MAX];
            int pFormat;
            memset(prop, 0, sizeof(prop));
            property_get("persist.camera.preview.ubwc", prop, "1");

            pFormat = atoi(prop);
            if (pFormat == 1) {
                mPreviewFormat = CAM_FORMAT_YUV_420_NV12_UBWC;
                mAppPreviewFormat = (cam_format_t)previewFormat;
            } else {
                mPreviewFormat = (cam_format_t)previewFormat;
                mAppPreviewFormat = (cam_format_t)previewFormat;
            }
        } else {
            mPreviewFormat = (cam_format_t)previewFormat;
            mAppPreviewFormat = (cam_format_t)previewFormat;
        }
        CameraParameters::setPreviewFormat(str);
        LOGH("format %d\n", mPreviewFormat);
        return NO_ERROR;
    }
    LOGE("Invalid preview format value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
}

/*===========================================================================
 * FUNCTION   : setPictureFormat
 *
 * DESCRIPTION: set picture format from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setPictureFormat(const QCameraParameters& params)
{
    const char *str = params.getPictureFormat();
    int32_t pictureFormat = lookupAttr(PICTURE_TYPES_MAP, PARAM_MAP_SIZE(PICTURE_TYPES_MAP), str);
    if (pictureFormat != NAME_NOT_FOUND) {
        mPictureFormat = pictureFormat;

        CameraParameters::setPictureFormat(str);
        LOGH("format %d\n", mPictureFormat);
        return NO_ERROR;
    }
    LOGE("Invalid picture format value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
}

/*===========================================================================
 * FUNCTION   : setJpegThumbnailSize
 *
 * DESCRIPTION: set jpeg thumbnail size from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setJpegThumbnailSize(const QCameraParameters& params)
{
    int width = params.getInt(KEY_JPEG_THUMBNAIL_WIDTH);
    int height = params.getInt(KEY_JPEG_THUMBNAIL_HEIGHT);

    LOGD("requested jpeg thumbnail size %d x %d", width, height);
    int sizes_cnt = sizeof(THUMBNAIL_SIZES_MAP) / sizeof(cam_dimension_t);
    // Validate thumbnail size
    for (int i = 0; i < sizes_cnt; i++) {
        if (width == THUMBNAIL_SIZES_MAP[i].width &&
                height == THUMBNAIL_SIZES_MAP[i].height) {
           set(KEY_JPEG_THUMBNAIL_WIDTH, width);
           set(KEY_JPEG_THUMBNAIL_HEIGHT, height);
           return NO_ERROR;
        }
    }
    LOGE("error: setting jpeg thumbnail size (%d, %d)", width, height);
    return BAD_VALUE;
}

/*===========================================================================

 * FUNCTION   : setBurstLEDOnPeriod
 *
 * DESCRIPTION: set burst LED on period
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setBurstLEDOnPeriod(const QCameraParameters& params)
{
    int nBurstLEDOnPeriod = params.getInt(KEY_QC_SNAPSHOT_BURST_LED_ON_PERIOD);
    //Check if the LED ON period is within limits
    if ((nBurstLEDOnPeriod <= 0) || (nBurstLEDOnPeriod > 800)) {
        // if burst led on period is not set in parameters,
        // read from sys prop
        char prop[PROPERTY_VALUE_MAX];
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.led.on.period", prop, "0");
        nBurstLEDOnPeriod = atoi(prop);
        if (nBurstLEDOnPeriod <= 0) {
            nBurstLEDOnPeriod = 300;
        }
    }

    set(KEY_QC_SNAPSHOT_BURST_LED_ON_PERIOD, nBurstLEDOnPeriod);
    m_nBurstLEDOnPeriod = nBurstLEDOnPeriod;
    LOGH("Burst LED on period  %u", m_nBurstLEDOnPeriod);
    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_BURST_LED_ON_PERIOD,
            (uint32_t)nBurstLEDOnPeriod)) {
        return BAD_VALUE;
    }

    return NO_ERROR;
}



/*===========================================================================
 * FUNCTION   : setRetroActiveBurstNum
 *
 * DESCRIPTION: set retro active burst num
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setRetroActiveBurstNum(
        const QCameraParameters& params)
{
    int32_t nBurstNum = params.getInt(KEY_QC_NUM_RETRO_BURST_PER_SHUTTER);
    LOGH("m_nRetroBurstNum = %d", m_nRetroBurstNum);
    if (nBurstNum <= 0) {
        // if burst number is not set in parameters,
        // read from sys prop
        char prop[PROPERTY_VALUE_MAX];
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.retro.number", prop, "0");
        nBurstNum = atoi(prop);
        if (nBurstNum < 0) {
            nBurstNum = 0;
        }
    }

    set(KEY_QC_NUM_RETRO_BURST_PER_SHUTTER, nBurstNum);

    m_nRetroBurstNum = nBurstNum;
    LOGH("m_nRetroBurstNum = %d", m_nRetroBurstNum);
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setJpegQuality
 *
 * DESCRIPTION: set jpeg encpding quality from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setJpegQuality(const QCameraParameters& params)
{
    int32_t rc = NO_ERROR;
    int quality = params.getInt(KEY_JPEG_QUALITY);
    if (quality >= 0 && quality <= 100) {
        set(KEY_JPEG_QUALITY, quality);
    } else {
        LOGE("Invalid jpeg quality=%d", quality);
        rc = BAD_VALUE;
    }

    quality = params.getInt(KEY_JPEG_THUMBNAIL_QUALITY);
    if (quality >= 0 && quality <= 100) {
        set(KEY_JPEG_THUMBNAIL_QUALITY, quality);
    } else {
        LOGE("Invalid jpeg thumbnail quality=%d", quality);
        rc = BAD_VALUE;
    }
    return rc;
}

/*===========================================================================
 * FUNCTION   : setOrientaion
 *
 * DESCRIPTION: set orientaion from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setOrientation(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_ORIENTATION);

    if (str != NULL) {
        if (strcmp(str, portrait) == 0 || strcmp(str, landscape) == 0) {
            // Camera service needs this to decide if the preview frames and raw
            // pictures should be rotated.
            set(KEY_QC_ORIENTATION, str);
        } else {
            LOGE("Invalid orientation value: %s", str);
            return BAD_VALUE;
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setAutoExposure
 *
 * DESCRIPTION: set auto exposure value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setAutoExposure(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_AUTO_EXPOSURE);
    const char *prev_str = get(KEY_QC_AUTO_EXPOSURE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setAutoExposure(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setPreviewFpsRange
 *
 * DESCRIPTION: set preview FPS range from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setPreviewFpsRange(const QCameraParameters& params)
{
    int minFps,maxFps;
    int prevMinFps, prevMaxFps, vidMinFps, vidMaxFps;
    int rc = NO_ERROR;
    bool found = false, updateNeeded = false;

    CameraParameters::getPreviewFpsRange(&prevMinFps, &prevMaxFps);
    params.getPreviewFpsRange(&minFps, &maxFps);

    LOGH("FpsRange Values:(%d, %d)", prevMinFps, prevMaxFps);
    LOGH("Requested FpsRange Values:(%d, %d)", minFps, maxFps);

    //first check if we need to change fps because of HFR mode change
    updateNeeded = UpdateHFRFrameRate(params);
    if (updateNeeded) {
        m_bNeedRestart = true;
        rc = setHighFrameRate(mHfrMode);
        if (rc != NO_ERROR) goto end;
    }
    LOGH("UpdateHFRFrameRate %d", updateNeeded);

    vidMinFps = (int)m_hfrFpsRange.video_min_fps;
    vidMaxFps = (int)m_hfrFpsRange.video_max_fps;

    if(minFps == prevMinFps && maxFps == prevMaxFps) {
        if ( m_bFixedFrameRateSet ) {
            minFps = params.getPreviewFrameRate() * 1000;
            maxFps = params.getPreviewFrameRate() * 1000;
            m_bFixedFrameRateSet = false;
        } else if (!updateNeeded) {
            LOGH("No change in FpsRange");
            rc = NO_ERROR;
            goto end;
        }
    }
    for(size_t i = 0; i < m_pCapability->fps_ranges_tbl_cnt; i++) {
        // if the value is in the supported list
        if (minFps >= m_pCapability->fps_ranges_tbl[i].min_fps * 1000 &&
                maxFps <= m_pCapability->fps_ranges_tbl[i].max_fps * 1000) {
            found = true;
            LOGH("FPS i=%d : minFps = %d, maxFps = %d"
                    " vidMinFps = %d, vidMaxFps = %d",
                     i, minFps, maxFps,
                    (int)m_hfrFpsRange.video_min_fps,
                    (int)m_hfrFpsRange.video_max_fps);
            if ((0.0f >= m_hfrFpsRange.video_min_fps) ||
                    (0.0f >= m_hfrFpsRange.video_max_fps)) {
                vidMinFps = minFps;
                vidMaxFps = maxFps;
            }
            else {
                vidMinFps = (int)m_hfrFpsRange.video_min_fps;
                vidMaxFps = (int)m_hfrFpsRange.video_max_fps;
            }

            setPreviewFpsRange(minFps, maxFps, vidMinFps, vidMaxFps);
            break;
        }
    }
    if(found == false){
        LOGE("error: FPS range value not supported");
        rc = BAD_VALUE;
    }
end:
    return rc;
}

/*===========================================================================
 * FUNCTION   : UpdateHFRFrameRate
 *
 * DESCRIPTION: set preview FPS range based on HFR setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : bool true/false
 *                  true -if HAL needs to overwrite FPS range set by app, false otherwise.
 *==========================================================================*/

bool QCameraParameters::UpdateHFRFrameRate(const QCameraParameters& params)
{
    bool updateNeeded = false;
    int min_fps, max_fps;
    int32_t hfrMode = CAM_HFR_MODE_OFF;
    int32_t newHfrMode = CAM_HFR_MODE_OFF;

    int parm_minfps,parm_maxfps;
    int prevMinFps, prevMaxFps;
    CameraParameters::getPreviewFpsRange(&prevMinFps, &prevMaxFps);
    params.getPreviewFpsRange(&parm_minfps, &parm_maxfps);
    LOGH("CameraParameters - : minFps = %d, maxFps = %d ",
                 prevMinFps, prevMaxFps);
    LOGH("Requested params - : minFps = %d, maxFps = %d ",
                 parm_minfps, parm_maxfps);

    const char *hfrStr = params.get(KEY_QC_VIDEO_HIGH_FRAME_RATE);
    const char *hsrStr = params.get(KEY_QC_VIDEO_HIGH_SPEED_RECORDING);

    const char *prev_hfrStr = CameraParameters::get(KEY_QC_VIDEO_HIGH_FRAME_RATE);
    const char *prev_hsrStr = CameraParameters::get(KEY_QC_VIDEO_HIGH_SPEED_RECORDING);

    if ((hfrStr != NULL) && (prev_hfrStr != NULL) && strcmp(hfrStr, prev_hfrStr)) {
        updateParamEntry(KEY_QC_VIDEO_HIGH_FRAME_RATE, hfrStr);
    }

    if ((hsrStr != NULL) && (prev_hsrStr != NULL) && strcmp(hsrStr, prev_hsrStr)) {
        updateParamEntry(KEY_QC_VIDEO_HIGH_SPEED_RECORDING, hsrStr);

    }

    // check if HFR is enabled
    if ((hfrStr != NULL) && strcmp(hfrStr, "off")) {
        hfrMode = lookupAttr(HFR_MODES_MAP, PARAM_MAP_SIZE(HFR_MODES_MAP), hfrStr);
        if (NAME_NOT_FOUND != hfrMode) newHfrMode = hfrMode;
    }
    // check if HSR is enabled
    else if ((hsrStr != NULL) && strcmp(hsrStr, "off")) {
        hfrMode = lookupAttr(HFR_MODES_MAP, PARAM_MAP_SIZE(HFR_MODES_MAP), hsrStr);
        if (NAME_NOT_FOUND != hfrMode) newHfrMode = hfrMode;
    }
    LOGH("prevHfrMode - %d, currentHfrMode = %d ",
                 mHfrMode, newHfrMode);

    if (mHfrMode != newHfrMode) {
        updateNeeded = true;
        mHfrMode = newHfrMode;
        switch (mHfrMode) {
            case CAM_HFR_MODE_60FPS:
                min_fps = 60000;
                max_fps = 60000;
                break;
            case CAM_HFR_MODE_90FPS:
                min_fps = 90000;
                max_fps = 90000;
                break;
            case CAM_HFR_MODE_120FPS:
                min_fps = 120000;
                max_fps = 120000;
                break;
            case CAM_HFR_MODE_150FPS:
                min_fps = 150000;
                max_fps = 150000;
                break;
            case CAM_HFR_MODE_180FPS:
                min_fps = 180000;
                max_fps = 180000;
                break;
            case CAM_HFR_MODE_210FPS:
                min_fps = 210000;
                max_fps = 210000;
                break;
            case CAM_HFR_MODE_240FPS:
                min_fps = 240000;
                max_fps = 240000;
                break;
            case CAM_HFR_MODE_480FPS:
                min_fps = 480000;
                max_fps = 480000;
                break;
            case CAM_HFR_MODE_OFF:
            default:
                // Set Video Fps to zero
                min_fps = 0;
                max_fps = 0;
                break;
        }
        m_hfrFpsRange.video_min_fps = (float)min_fps;
        m_hfrFpsRange.video_max_fps = (float)max_fps;

        LOGH("HFR mode (%d) Set video FPS : minFps = %d, maxFps = %d ",
                 mHfrMode, min_fps, max_fps);
    }

    // Remember if HFR mode is ON
    if ((mHfrMode > CAM_HFR_MODE_OFF) && (mHfrMode < CAM_HFR_MODE_MAX)) {
        LOGH("HFR mode is ON");
        m_bHfrMode = true;
    } else {
        m_hfrFpsRange.video_min_fps = 0;
        m_hfrFpsRange.video_max_fps = 0;
        m_bHfrMode = false;
        LOGH("HFR mode is OFF");
    }
    m_hfrFpsRange.min_fps = (float)parm_minfps;
    m_hfrFpsRange.max_fps = (float)parm_maxfps;

    if (m_bHfrMode && (mHfrMode > CAM_HFR_MODE_120FPS)
            && (parm_maxfps != 0)) {
        //Configure buffer batch count to use batch mode for higher fps
        setBufBatchCount((int8_t)(m_hfrFpsRange.video_max_fps / parm_maxfps));
    } else {
        //Reset batch count and update KEY for encoder
        setBufBatchCount(0);
    }
    return updateNeeded;
}

/*===========================================================================
 * FUNCTION   : setPreviewFrameRate
 *
 * DESCRIPTION: set preview frame rate from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setPreviewFrameRate(const QCameraParameters& params)
{
    const char *str = params.get(KEY_PREVIEW_FRAME_RATE);
    const char *prev_str = get(KEY_PREVIEW_FRAME_RATE);

    if ( str ) {
        if ( prev_str &&
             strcmp(str, prev_str)) {
            LOGD("Requested Fixed Frame Rate %s", str);
            updateParamEntry(KEY_PREVIEW_FRAME_RATE, str);
            m_bFixedFrameRateSet = true;
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setEffect
 *
 * DESCRIPTION: set effect value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setEffect(const QCameraParameters& params)
{
    const char *str = params.get(KEY_EFFECT);
    const char *prev_str = get(KEY_EFFECT);

    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));
    property_get("persist.camera.effect", prop, "none");

    if (strcmp(prop, "none")) {
        if ((prev_str == NULL) ||
                (strcmp(prop, prev_str) != 0) ||
                (m_bUpdateEffects == true)) {
            m_bUpdateEffects = false;
            return setEffect(prop);
        }
    } else if (str != NULL) {
        if ((prev_str == NULL) ||
                (strcmp(str, prev_str) != 0) ||
                (m_bUpdateEffects == true)) {
            m_bUpdateEffects = false;
            return setEffect(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setFocusMode
 *
 * DESCRIPTION: set focus mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setFocusMode(const QCameraParameters& params)
{
    const char *str = params.get(KEY_FOCUS_MODE);
    const char *prev_str = get(KEY_FOCUS_MODE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setFocusMode(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setFocusPosition
 *
 * DESCRIPTION: set focus position from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t  QCameraParameters::setFocusPosition(const QCameraParameters& params)
{
    const char *focus_str = params.get(KEY_FOCUS_MODE);
    const char *prev_focus_str = get(KEY_FOCUS_MODE);

    if (NULL == focus_str) {
        return NO_ERROR;
    }

    LOGD("current focus mode: %s", focus_str);
    if (strcmp(focus_str, FOCUS_MODE_MANUAL_POSITION)) {
        LOGH(", dont set focus pos to back-end!");
        return NO_ERROR;
    }

    const char *pos = params.get(KEY_QC_MANUAL_FOCUS_POSITION);
    const char *prev_pos = get(KEY_QC_MANUAL_FOCUS_POSITION);
    const char *type = params.get(KEY_QC_MANUAL_FOCUS_POS_TYPE);
    const char *prev_type = get(KEY_QC_MANUAL_FOCUS_POS_TYPE);

    if ((pos != NULL) && (type != NULL) && (focus_str != NULL)) {
        if (prev_pos  == NULL || (strcmp(pos, prev_pos) != 0) ||
            prev_type == NULL || (strcmp(type, prev_type) != 0) ||
            prev_focus_str == NULL || (strcmp(focus_str, prev_focus_str) != 0)) {
            return setFocusPosition(type, pos);
        }
    }

    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setBrightness
 *
 * DESCRIPTION: set brightness control value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setBrightness(const QCameraParameters& params)
{
    int currentBrightness = getInt(KEY_QC_BRIGHTNESS);
    int brightness = params.getInt(KEY_QC_BRIGHTNESS);

    if(params.get(KEY_QC_BRIGHTNESS) == NULL) {
       LOGH("Brigtness not set by App ");
       return NO_ERROR;
    }
    if (currentBrightness !=  brightness) {
        if (brightness >= m_pCapability->brightness_ctrl.min_value &&
            brightness <= m_pCapability->brightness_ctrl.max_value) {
            LOGD("new brightness value : %d ", brightness);
            return setBrightness(brightness);
        } else {
            LOGE("invalid value %d out of (%d, %d)",
                   brightness,
                  m_pCapability->brightness_ctrl.min_value,
                  m_pCapability->brightness_ctrl.max_value);
            return BAD_VALUE;
        }
    } else {
        LOGD("No brightness value changed.");
        return NO_ERROR;
    }
}

/*===========================================================================
 * FUNCTION   : getBrightness
 *
 * DESCRIPTION: get brightness control value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int QCameraParameters::getBrightness()
{
    return getInt(KEY_QC_BRIGHTNESS);
}

/*===========================================================================
 * FUNCTION   : setSharpness
 *
 * DESCRIPTION: set sharpness control value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setSharpness(const QCameraParameters& params)
{
    int shaprness = params.getInt(KEY_QC_SHARPNESS);
    int prev_sharp = getInt(KEY_QC_SHARPNESS);

    if(params.get(KEY_QC_SHARPNESS) == NULL) {
       LOGH("Sharpness not set by App ");
       return NO_ERROR;
    }
    if (prev_sharp !=  shaprness) {
        if((shaprness >= m_pCapability->sharpness_ctrl.min_value) &&
           (shaprness <= m_pCapability->sharpness_ctrl.max_value)) {
            LOGD("new sharpness value : %d ", shaprness);
            return setSharpness(shaprness);
        } else {
            LOGE("invalid value %d out of (%d, %d)",
                   shaprness,
                  m_pCapability->sharpness_ctrl.min_value,
                  m_pCapability->sharpness_ctrl.max_value);
            return BAD_VALUE;
        }
    } else {
        LOGD("No value change in shaprness");
        return NO_ERROR;
    }
}

/*===========================================================================
 * FUNCTION   : setSkintoneEnahancement
 *
 * DESCRIPTION: set skin tone enhancement factor from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setSkinToneEnhancement(const QCameraParameters& params)
{
    int sceFactor = params.getInt(KEY_QC_SCE_FACTOR);
    int prev_sceFactor = getInt(KEY_QC_SCE_FACTOR);

    if(params.get(KEY_QC_SCE_FACTOR) == NULL) {
       LOGH("Skintone enhancement not set by App ");
       return NO_ERROR;
    }
    if (prev_sceFactor != sceFactor) {
        if((sceFactor >= m_pCapability->sce_ctrl.min_value) &&
           (sceFactor <= m_pCapability->sce_ctrl.max_value)) {
            LOGD("new Skintone Enhancement value : %d ", sceFactor);
            return setSkinToneEnhancement(sceFactor);
        } else {
            LOGE("invalid value %d out of (%d, %d)",
                   sceFactor,
                  m_pCapability->sce_ctrl.min_value,
                  m_pCapability->sce_ctrl.max_value);
            return BAD_VALUE;
        }
    } else {
        LOGD("No value change in skintone enhancement factor");
        return NO_ERROR;
    }
}

/*===========================================================================
 * FUNCTION   : setSaturation
 *
 * DESCRIPTION: set saturation control value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setSaturation(const QCameraParameters& params)
{
    int saturation = params.getInt(KEY_QC_SATURATION);
    int prev_sat = getInt(KEY_QC_SATURATION);

    if(params.get(KEY_QC_SATURATION) == NULL) {
       LOGH("Saturation not set by App ");
       return NO_ERROR;
    }
    if (prev_sat !=  saturation) {
        if((saturation >= m_pCapability->saturation_ctrl.min_value) &&
           (saturation <= m_pCapability->saturation_ctrl.max_value)) {
            LOGD("new saturation value : %d ", saturation);
            return setSaturation(saturation);
        } else {
            LOGE("invalid value %d out of (%d, %d)",
                   saturation,
                  m_pCapability->saturation_ctrl.min_value,
                  m_pCapability->saturation_ctrl.max_value);
            return BAD_VALUE;
        }
    } else {
        LOGD("No value change in saturation factor");
        return NO_ERROR;
    }
}

/*===========================================================================
 * FUNCTION   : setContrast
 *
 * DESCRIPTION: set contrast control value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setContrast(const QCameraParameters& params)
{
    int contrast = params.getInt(KEY_QC_CONTRAST);
    int prev_contrast = getInt(KEY_QC_CONTRAST);

    if(params.get(KEY_QC_CONTRAST) == NULL) {
       LOGH("Contrast not set by App ");
       return NO_ERROR;
    }
    if (prev_contrast !=  contrast) {
        if((contrast >= m_pCapability->contrast_ctrl.min_value) &&
           (contrast <= m_pCapability->contrast_ctrl.max_value)) {
            LOGD("new contrast value : %d ", contrast);
            int32_t rc = setContrast(contrast);
            return rc;
        } else {
            LOGE("invalid value %d out of (%d, %d)",
                   contrast,
                  m_pCapability->contrast_ctrl.min_value,
                  m_pCapability->contrast_ctrl.max_value);
            return BAD_VALUE;
        }
    } else {
        LOGD("No value change in contrast");
        return NO_ERROR;
    }
}

/*===========================================================================
 * FUNCTION   : setExposureCompensation
 *
 * DESCRIPTION: set exposure compensation value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setExposureCompensation(const QCameraParameters & params)
{
    int expComp = params.getInt(KEY_EXPOSURE_COMPENSATION);
    int prev_expComp = getInt(KEY_EXPOSURE_COMPENSATION);

    if(params.get(KEY_EXPOSURE_COMPENSATION) == NULL) {
       LOGH("Exposure compensation not set by App ");
       return NO_ERROR;
    }
    if (prev_expComp != expComp) {
        if((expComp >= m_pCapability->exposure_compensation_min) &&
           (expComp <= m_pCapability->exposure_compensation_max)) {
            LOGD("new Exposure Compensation value : %d ", expComp);
            return setExposureCompensation(expComp);
        } else {
            LOGE("invalid value %d out of (%d, %d)",
                   expComp,
                  m_pCapability->exposure_compensation_min,
                  m_pCapability->exposure_compensation_max);
            return BAD_VALUE;
        }
    } else {
        LOGD("No value change in Exposure Compensation");
        return NO_ERROR;
    }
}

/*===========================================================================
 * FUNCTION   : setWhiteBalance
 *
 * DESCRIPTION: set white balance value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setWhiteBalance(const QCameraParameters& params)
{
    const char *str = params.get(KEY_WHITE_BALANCE);
    const char *prev_str = get(KEY_WHITE_BALANCE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setWhiteBalance(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setManualWhiteBalance
 *
 * DESCRIPTION: set manual white balance from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t  QCameraParameters::setManualWhiteBalance(const QCameraParameters& params)
{
    int32_t rc = NO_ERROR;
    const char *wb_str = params.get(KEY_WHITE_BALANCE);
    const char *prev_wb_str = get(KEY_WHITE_BALANCE);
    LOGD("current wb mode: %s", wb_str);

    if (wb_str != NULL) {
        if (strcmp(wb_str, WHITE_BALANCE_MANUAL)) {
            LOGD("dont set cct to back-end.");
            return NO_ERROR;
        }
    }

    const char *value = params.get(KEY_QC_MANUAL_WB_VALUE);
    const char *prev_value = get(KEY_QC_MANUAL_WB_VALUE);
    const char *type = params.get(KEY_QC_MANUAL_WB_TYPE);
    const char *prev_type = get(KEY_QC_MANUAL_WB_TYPE);

    if ((value != NULL) && (type != NULL) && (wb_str != NULL)) {
        if (prev_value  == NULL || (strcmp(value, prev_value) != 0) ||
            prev_type == NULL || (strcmp(type, prev_type) != 0) ||
            prev_wb_str == NULL || (strcmp(wb_str, prev_wb_str) != 0)) {
            updateParamEntry(KEY_QC_MANUAL_WB_TYPE, type);
            updateParamEntry(KEY_QC_MANUAL_WB_VALUE, value);
            int32_t wb_type = atoi(type);
            if (wb_type == CAM_MANUAL_WB_MODE_CCT) {
                rc = setWBManualCCT(value);
            } else if (wb_type == CAM_MANUAL_WB_MODE_GAIN) {
                rc = setManualWBGains(value);
            } else {
                rc = BAD_VALUE;
            }
        }
    }
    return rc;
}

/*===========================================================================
 * FUNCTION   : setAntibanding
 *
 * DESCRIPTION: set antibanding value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setAntibanding(const QCameraParameters& params)
{
    const char *str = params.get(KEY_ANTIBANDING);
    const char *prev_str = get(KEY_ANTIBANDING);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setAntibanding(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setStatsDebugMask
 *
 * DESCRIPTION: get the value from persist file in Stats module that will
 *              control funtionality in the module
 *
 * PARAMETERS : none
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setStatsDebugMask()
{
    uint32_t mask = 0;
    char value[PROPERTY_VALUE_MAX];

    property_get("persist.camera.stats.debug.mask", value, "0");
    mask = (uint32_t)atoi(value);

    LOGH("ctrl mask :%d", mask);

    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_STATS_DEBUG_MASK, mask)) {
        return BAD_VALUE;
    }

    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setPAAF
 *
 * DESCRIPTION: get the value from persist file in Stats module that will
 *              control the preview assisted AF in the module
 *
 * PARAMETERS : none
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setPAAF()
{
    uint32_t paaf = 0;
    char value[PROPERTY_VALUE_MAX];

    property_get("persist.camera.stats.af.paaf", value, "1");
    paaf = (uint32_t)atoi(value);

    LOGH("PAAF is: %s", paaf ? "ON": "OFF");

    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_STATS_AF_PAAF, paaf)) {
        return BAD_VALUE;
    }

    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setSceneDetect
 *
 * DESCRIPTION: set scenen detect value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setSceneDetect(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_SCENE_DETECT);
    const char *prev_str = get(KEY_QC_SCENE_DETECT);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setSceneDetect(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setVideoHDR
 *
 * DESCRIPTION: set video HDR value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setVideoHDR(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_VIDEO_HDR);
    const char *prev_str = get(KEY_QC_VIDEO_HDR);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setVideoHDR(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setVtEnable
 *
 * DESCRIPTION: set vt Time Stamp enable from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setVtEnable(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_VT_ENABLE);
    const char *prev_str = get(KEY_QC_VT_ENABLE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setVtEnable(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setFaceRecognition
 *
 * DESCRIPTION: set face recognition mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setFaceRecognition(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_FACE_RECOGNITION);
    const char *prev_str = get(KEY_QC_FACE_RECOGNITION);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            uint32_t maxFaces = (uint32_t)params.getInt(KEY_QC_MAX_NUM_REQUESTED_FACES);
            return setFaceRecognition(str, maxFaces);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setZoom
 *
 * DESCRIPTION: set zoom value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setZoom(const QCameraParameters& params)
{
    if ((m_pCapability->zoom_supported == 0 ||
         m_pCapability->zoom_ratio_tbl_cnt == 0)) {
        LOGH("no zoom support");
        return NO_ERROR;
    }

    int zoomLevel = params.getInt(KEY_ZOOM);
    mParmZoomLevel = zoomLevel;
    if ((zoomLevel < 0) || (zoomLevel >= (int)m_pCapability->zoom_ratio_tbl_cnt)) {
        LOGE("invalid value %d out of (%d, %d)",
               zoomLevel,
              0, m_pCapability->zoom_ratio_tbl_cnt-1);
        return BAD_VALUE;
    }

    int prevZoomLevel = getInt(KEY_ZOOM);
    if (prevZoomLevel == zoomLevel) {
        LOGD("No value change in zoom %d %d", prevZoomLevel, zoomLevel);
        return NO_ERROR;
    }

    return setZoom(zoomLevel);
}

/*===========================================================================
 * FUNCTION   : setISOValue
 *
 * DESCRIPTION: set ISO value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t  QCameraParameters::setISOValue(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_ISO_MODE);
    const char *prev_str = get(KEY_QC_ISO_MODE);

    if(getManualCaptureMode()) {
        char iso_val[PROPERTY_VALUE_MAX];

        property_get("persist.camera.iso", iso_val, "");
        if (strlen(iso_val) > 0) {
            if (prev_str == NULL ||
                    strcmp(iso_val, prev_str) != 0) {
                return setISOValue(iso_val);
            }
        }
    } else if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setISOValue(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setContinuousISO
 *
 * DESCRIPTION: set ISO value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t  QCameraParameters::setContinuousISO(const char *isoValue)
{
    char iso[PROPERTY_VALUE_MAX];
    int32_t continous_iso = 0;

    // Check if continuous ISO is set through setproperty
    property_get("persist.camera.continuous.iso", iso, "");
    if (strlen(iso) > 0) {
        continous_iso = atoi(iso);
    } else {
        continous_iso = atoi(isoValue);
    }

    if ((continous_iso >= 0) &&
            (continous_iso <= m_pCapability->sensitivity_range.max_sensitivity)) {
        LOGH("Setting continuous ISO value %d", continous_iso);
        updateParamEntry(KEY_QC_CONTINUOUS_ISO, isoValue);

        cam_intf_parm_manual_3a_t iso_settings;
        memset(&iso_settings, 0, sizeof(cam_intf_parm_manual_3a_t));
        iso_settings.previewOnly = FALSE;
        iso_settings.value = continous_iso;
        if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_ISO, iso_settings)) {
            return BAD_VALUE;
        }
        return NO_ERROR;
    }
    LOGE("Invalid iso value: %d", continous_iso);
    return BAD_VALUE;
}

/*===========================================================================
 * FUNCTION   : setExposureTime
 *
 * DESCRIPTION: set exposure time from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t  QCameraParameters::setExposureTime(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_EXPOSURE_TIME);
    const char *prev_str = get(KEY_QC_EXPOSURE_TIME);
    if (str != NULL) {
        if (prev_str == NULL ||
                strcmp(str, prev_str) != 0) {
            return setExposureTime(str);
        }
    } else if(getManualCaptureMode()) {
        char expTime[PROPERTY_VALUE_MAX];

        property_get("persist.camera.exposure.time", expTime, "");
        if (strlen(expTime) > 0) {
            if (prev_str == NULL ||
                    strcmp(expTime, prev_str) != 0) {
                return setExposureTime(expTime);
            }
        }
    }

    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setVideoRotation
 *
 * DESCRIPTION: set rotation value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setVideoRotation(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_VIDEO_ROTATION);
    if(str != NULL) {
        int value = lookupAttr(VIDEO_ROTATION_MODES_MAP,
                PARAM_MAP_SIZE(VIDEO_ROTATION_MODES_MAP), str);
        if (value != NAME_NOT_FOUND) {
            updateParamEntry(KEY_QC_VIDEO_ROTATION, str);
            LOGL("setVideoRotation:   %d: ", str, value);
        } else {
            LOGE("Invalid rotation value: %d", value);
            return BAD_VALUE;
        }

    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setRotation
 *
 * DESCRIPTION: set rotation value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setRotation(const QCameraParameters& params)
{
    int32_t rotation = params.getInt(KEY_ROTATION);
    if (rotation != -1) {
        if (rotation == 0 || rotation == 90 ||
            rotation == 180 || rotation == 270) {
            set(KEY_ROTATION, rotation);

            ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_META_JPEG_ORIENTATION,
                    rotation);
            mRotation = rotation;
        } else {
            LOGE("Invalid rotation value: %d", rotation);
            return BAD_VALUE;
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setFlash
 *
 * DESCRIPTION: set flash mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setFlash(const QCameraParameters& params)
{
    const char *str = params.get(KEY_FLASH_MODE);
    const char *prev_str = get(KEY_FLASH_MODE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setFlash(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setAecLock
 *
 * DESCRIPTION: set AEC lock value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setAecLock(const QCameraParameters& params)
{
    const char *str = params.get(KEY_AUTO_EXPOSURE_LOCK);
    const char *prev_str = get(KEY_AUTO_EXPOSURE_LOCK);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setAecLock(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setAwbLock
 *
 * DESCRIPTION: set AWB lock from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setAwbLock(const QCameraParameters& params)
{
    const char *str = params.get(KEY_AUTO_WHITEBALANCE_LOCK);
    const char *prev_str = get(KEY_AUTO_WHITEBALANCE_LOCK);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setAwbLock(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setAutoHDR
 *
 * DESCRIPTION: Enable/disable auto HDR
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setAutoHDR(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_AUTO_HDR_ENABLE);
    const char *prev_str = get(KEY_QC_AUTO_HDR_ENABLE);
    char prop[PROPERTY_VALUE_MAX];

    memset(prop, 0, sizeof(prop));
    property_get("persist.camera.auto.hdr.enable", prop, VALUE_DISABLE);
    if (str != NULL) {
       if (prev_str == NULL ||
           strcmp(str, prev_str) != 0) {
           LOGH("Auto HDR set to: %s", str);
           return updateParamEntry(KEY_QC_AUTO_HDR_ENABLE, str);
       }
    } else {
       if (prev_str == NULL ||
           strcmp(prev_str, prop) != 0 ) {
           LOGH("Auto HDR set to: %s", prop);
           updateParamEntry(KEY_QC_AUTO_HDR_ENABLE, prop);
       }
    }

       return NO_ERROR;
}

/*===========================================================================
* FUNCTION   : isAutoHDREnabled
*
* DESCRIPTION: Query auto HDR status
*
* PARAMETERS : None
*
* RETURN     : bool true/false
*==========================================================================*/
bool QCameraParameters::isAutoHDREnabled()
{
    const char *str = get(KEY_QC_AUTO_HDR_ENABLE);
    if (str != NULL) {
        int32_t value = lookupAttr(ENABLE_DISABLE_MODES_MAP,
                PARAM_MAP_SIZE(ENABLE_DISABLE_MODES_MAP), str);
        if (value == NAME_NOT_FOUND) {
            LOGE("Invalid Auto HDR value %s", str);
            return false;
        }

        LOGH("Auto HDR status is: %d", value);
        return value ? true : false;
    }

    LOGH("Auto HDR status not set!");
    return false;
}

/*===========================================================================
 * FUNCTION   : setMCEValue
 *
 * DESCRIPTION: set memory color enhancement value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setMCEValue(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_MEMORY_COLOR_ENHANCEMENT);
    const char *prev_str = get(KEY_QC_MEMORY_COLOR_ENHANCEMENT);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setMCEValue(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setDISValue
 *
 * DESCRIPTION: enable/disable DIS from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setDISValue(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_DIS);
    const char *prev_str = get(KEY_QC_DIS);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setDISValue(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setLensShadeValue
 *
 * DESCRIPTION: set lens shade value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setLensShadeValue(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_LENSSHADE);
    const char *prev_str = get(KEY_QC_LENSSHADE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setLensShadeValue(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setFocusAreas
 *
 * DESCRIPTION: set focus areas from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setFocusAreas(const QCameraParameters& params)
{
    const char *str = params.get(KEY_FOCUS_AREAS);

    if (getRelatedCamSyncInfo()->mode == CAM_MODE_SECONDARY) {
        // Ignore focus areas for secondary camera
        LOGH("Ignore focus areas for secondary camera!! ");
        return NO_ERROR;
    }
    if (str != NULL) {
        int max_num_af_areas = getInt(KEY_MAX_NUM_FOCUS_AREAS);
        if(max_num_af_areas == 0) {
            LOGE("max num of AF area is 0, cannot set focus areas");
            return BAD_VALUE;
        }

        const char *prev_str = get(KEY_FOCUS_AREAS);
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setFocusAreas(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setMeteringAreas
 *
 * DESCRIPTION: set metering areas from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setMeteringAreas(const QCameraParameters& params)
{
    const char *str = params.get(KEY_METERING_AREAS);
    if (str != NULL) {
        int max_num_mtr_areas = getInt(KEY_MAX_NUM_METERING_AREAS);
        if(max_num_mtr_areas == 0) {
            LOGE("max num of metering areas is 0, cannot set focus areas");
            return BAD_VALUE;
        }

        const char *prev_str = get(KEY_METERING_AREAS);
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0 ||
            (m_bNeedRestart == true)) {
            return setMeteringAreas(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setSceneMode
 *
 * DESCRIPTION: set scenen mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setSceneMode(const QCameraParameters& params)
{
    const char *str = params.get(KEY_SCENE_MODE);
    const char *prev_str = get(KEY_SCENE_MODE);
    LOGH("str - %s, prev_str - %s", str, prev_str);

    // HDR & Recording are mutually exclusive and so disable HDR if recording hint is set
    if (m_bRecordingHint_new && m_bHDREnabled) {
        LOGH("Disable the HDR and set it to Auto");
        str = SCENE_MODE_AUTO;
        m_bLocalHDREnabled = true;
    } else if (!m_bRecordingHint_new && m_bLocalHDREnabled) {
        LOGH("Restore the HDR from Auto scene mode");
        str = SCENE_MODE_HDR;
        m_bLocalHDREnabled = false;
    }

    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {

            if(strcmp(str, SCENE_MODE_AUTO) == 0) {
                m_bSceneTransitionAuto = true;
            }
            if (strcmp(str, SCENE_MODE_HDR) == 0) {

                // If HDR is set from client  and the feature is not enabled in the backend, ignore it.
                if (m_bHDRModeSensor && isSupportedSensorHdrSize(params)) {
                    m_bSensorHDREnabled = true;
                    m_bHDREnabled = false;
                    LOGH("Sensor HDR mode Enabled");
                } else {
                    m_bHDREnabled = true;
                    LOGH("S/W HDR Enabled");
                }
            } else {
                m_bHDREnabled = false;
                if (m_bSensorHDREnabled) {
                    m_bSensorHDREnabled = false;
                    m_bNeedRestart = true;
                    setSensorSnapshotHDR("off");
                }
            }

            if (m_bSensorHDREnabled) {
                setSensorSnapshotHDR("on");
                m_bNeedRestart = true;
            } else if ((m_bHDREnabled) ||
                ((prev_str != NULL) && (strcmp(prev_str, SCENE_MODE_HDR) == 0))) {
                LOGH("scene mode changed between HDR and non-HDR, need restart");
                m_bNeedRestart = true;
            }

            return setSceneMode(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setSelectableZoneAf
 *
 * DESCRIPTION: set selectable zone auto focus value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setSelectableZoneAf(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_SELECTABLE_ZONE_AF);
    const char *prev_str = get(KEY_QC_SELECTABLE_ZONE_AF);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setSelectableZoneAf(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setAEBracket
 *
 * DESCRIPTION: set AE bracket from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setAEBracket(const QCameraParameters& params)
{
    if (isHDREnabled()) {
        LOGH("scene mode is HDR, overwrite AE bracket setting to off");
        return setAEBracket(AE_BRACKET_OFF);
    }

    const char *expStr = params.get(KEY_QC_CAPTURE_BURST_EXPOSURE);
    if (NULL != expStr && strlen(expStr) > 0) {
        set(KEY_QC_CAPTURE_BURST_EXPOSURE, expStr);
    } else {
        char prop[PROPERTY_VALUE_MAX];
        memset(prop, 0, sizeof(prop));
        property_get("persist.capture.burst.exposures", prop, "");
        if (strlen(prop) > 0) {
            set(KEY_QC_CAPTURE_BURST_EXPOSURE, prop);
        } else {
            remove(KEY_QC_CAPTURE_BURST_EXPOSURE);
        }
    }

    const char *str = params.get(KEY_QC_AE_BRACKET_HDR);
    const char *prev_str = get(KEY_QC_AE_BRACKET_HDR);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setAEBracket(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setAFBracket
 *
 * DESCRIPTION: set AF bracket from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setAFBracket(const QCameraParameters& params)
{
    if ((m_pCapability->qcom_supported_feature_mask &
            (CAM_QCOM_FEATURE_REFOCUS | CAM_QCOM_FEATURE_UBIFOCUS)) == 0) {
        LOGH("AF Bracketing is not supported");
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_AF_BRACKET);
    const char *prev_str = get(KEY_QC_AF_BRACKET);
    LOGH("str =%s & prev_str =%s", str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setAFBracket(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setReFocus
 *
 * DESCRIPTION: set refocus from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setReFocus(const QCameraParameters& params)
{
    if ((m_pCapability->qcom_supported_feature_mask &
            (CAM_QCOM_FEATURE_REFOCUS | CAM_QCOM_FEATURE_UBIFOCUS)) == 0) {
        LOGD("AF Bracketing is not supported");
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_RE_FOCUS);
    const char *prev_str = get(KEY_QC_RE_FOCUS);
    LOGH("str =%s & prev_str =%s", str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setReFocus(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setChromaFlash
 *
 * DESCRIPTION: set chroma flash from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setChromaFlash(const QCameraParameters& params)
{
    if ((m_pCapability->qcom_supported_feature_mask &
        CAM_QCOM_FEATURE_CHROMA_FLASH) == 0) {
        LOGH("Chroma Flash is not supported");
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_CHROMA_FLASH);
    const char *prev_str = get(KEY_QC_CHROMA_FLASH);
    LOGH("str =%s & prev_str =%s", str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setChromaFlash(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setOptiZoom
 *
 * DESCRIPTION: set opti zoom from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setOptiZoom(const QCameraParameters& params)
{
    if ((m_pCapability->qcom_supported_feature_mask &
        CAM_QCOM_FEATURE_OPTIZOOM) == 0){
        LOGH("Opti Zoom is not supported");
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_OPTI_ZOOM);
    const char *prev_str = get(KEY_QC_OPTI_ZOOM);
    LOGH("str =%s & prev_str =%s", str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setOptiZoom(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setTruePortrait
 *
 * DESCRIPTION: set true portrait from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setTruePortrait(const QCameraParameters& params)
{
    if ((m_pCapability->qcom_supported_feature_mask &
            CAM_QCOM_FEATURE_TRUEPORTRAIT) == 0) {
        LOGD("True Portrait is not supported");
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_TRUE_PORTRAIT);
    const char *prev_str = get(KEY_QC_TRUE_PORTRAIT);
    LOGH("str =%s & prev_str =%s", str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setTruePortrait(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setHDRMode
 *
 * DESCRIPTION: set HDR mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setHDRMode(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_HDR_MODE);
    const char *prev_str = get(KEY_QC_HDR_MODE);
    uint32_t supported_hdr_modes = m_pCapability->qcom_supported_feature_mask &
          (CAM_QCOM_FEATURE_SENSOR_HDR | CAM_QCOM_FEATURE_HDR);

    LOGH("str =%s & prev_str =%s", str, prev_str);
    if (str != NULL) {
        if ((CAM_QCOM_FEATURE_SENSOR_HDR == supported_hdr_modes) &&
                (strncmp(str, HDR_MODE_SENSOR, strlen(HDR_MODE_SENSOR)))) {
            LOGH("Only sensor HDR is supported");
            return NO_ERROR;
        } else if  ((CAM_QCOM_FEATURE_HDR == supported_hdr_modes) &&
                (strncmp(str, HDR_MODE_SENSOR, strlen(HDR_MODE_MULTI_FRAME)))) {
            LOGH("Only multi frame HDR is supported");
            return NO_ERROR;
        } else if (!supported_hdr_modes) {
            LOGH("HDR is not supported");
            return NO_ERROR;
        }
        if (prev_str == NULL ||
                strcmp(str, prev_str) != 0) {
            return setHDRMode(str);
        }
    }

    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setHDRNeed1x
 *
 * DESCRIPTION: set HDR need 1x from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setHDRNeed1x(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_HDR_NEED_1X);
    const char *prev_str = get(KEY_QC_HDR_NEED_1X);

    LOGH("str =%s & prev_str =%s", str, prev_str);
    if (str != NULL) {
        if (m_bHDRModeSensor) {
            LOGH("Only multi frame HDR supports 1x frame");
            return NO_ERROR;
        }
        if ((prev_str == NULL) || (strcmp(str, prev_str) != 0)) {
            return setHDRNeed1x(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setQuadraCfaMode
 *
 * DESCRIPTION: enable or disable Quadra CFA mode
 *
 * PARAMETERS :
 *   @enable : enable: 1; disable 0
 *   @initCommit: if configuration list needs to be initialized and commited
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setQuadraCfaMode(uint32_t enable, bool initCommit) {

   int32_t rc = NO_ERROR;

    if (getQuadraCfa()) {
        if (enable) {
            setOfflineRAW(TRUE);
        } else  {
            setOfflineRAW(FALSE);
        }
        if (initCommit) {
            if (initBatchUpdate(m_pParamBuf) < 0) {
                LOGE("Failed to initialize group update table");
                return FAILED_TRANSACTION;
            }
        }
        if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_QUADRA_CFA, enable)) {
            LOGE("Failed to update Quadra CFA mode");
            return BAD_VALUE;
        }
        if (initCommit) {
            rc = commitSetBatch();
            if (rc != NO_ERROR) {
                LOGE("Failed to commit Quadra CFA mode");
                return rc;
            }
        }
        LOGI("Quadra CFA mode %d ", enable);
    }
    return rc;
}

/*===========================================================================
 * FUNCTION   : setQuadraCFA
 *
 * DESCRIPTION: set Quadra CFA mode
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setQuadraCfa(const QCameraParameters& params)
{

    int32_t width = 0,height = 0;
    bool prev_quadracfa = getQuadraCfa();
    int32_t rc = NO_ERROR;
    int32_t value;

    if (!m_pCapability->is_remosaic_lib_present) {
        LOGD("Quadra CFA mode not supported");
        return rc;
    }

    /*Checking if the user selected dim is more than maximum dim supported by
    Quadra sensor in normal mode. If more then switch to Quadra CFA mode else
    remain in normal zsl mode */
    params.getPictureSize(&width, &height);
    if (width > m_pCapability->raw_dim[0].width ||
        height > m_pCapability->raw_dim[0].height) {
        LOGI("Quadra CFA mode selected");
        m_bQuadraCfa = TRUE;
    } else {
        LOGI("Quadra CFA mode not selected");
        m_bQuadraCfa = FALSE;
    }
    value = m_bQuadraCfa;
    if (prev_quadracfa == m_bQuadraCfa) {
        LOGD("No change in Quadra CFA mode");
    } else {
        if (m_bZslMode && m_bQuadraCfa) {
            m_bNeedRestart = TRUE;
            setZslMode(FALSE);
        } else {
            const char *str_val  = params.get(KEY_QC_ZSL);
            int32_t value = lookupAttr(ON_OFF_MODES_MAP, PARAM_MAP_SIZE(ON_OFF_MODES_MAP),
                    str_val);
            if (value != NAME_NOT_FOUND && value) {
                rc = setZslMode(value);
                // ZSL mode changed, need restart preview
                m_bNeedRestart = true;
            }
        }
        setReprocCount();
    }
    LOGH("Quadra CFA mode = %d", m_bQuadraCfa);
    return rc;
}
/*===========================================================================
 * FUNCTION   : setSeeMore
 *
 * DESCRIPTION: set see more (llvd) from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setSeeMore(const QCameraParameters& params)
{
    if ((m_pCapability->qcom_supported_feature_mask &
            CAM_QCOM_FEATURE_LLVD) == 0) {
        LOGD("See more is not supported");
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_SEE_MORE);
    const char *prev_str = get(KEY_QC_SEE_MORE);
    LOGH("str =%s & prev_str =%s", str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL || strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setSeeMore(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setNoiseReductionMode
 *
 * DESCRIPTION: set noise reduction mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setNoiseReductionMode(const QCameraParameters& params)
{
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QTI_FEATURE_SW_TNR) == 0) {
        LOGD("SW TNR is not supported");
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_NOISE_REDUCTION_MODE);
    const char *prev_str = get(KEY_QC_NOISE_REDUCTION_MODE);
    LOGH("str =%s & prev_str =%s", str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL || strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setNoiseReductionMode(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setStillMore
 *
 * DESCRIPTION: set stillmore from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setStillMore(const QCameraParameters& params)
{
    if ((m_pCapability->qcom_supported_feature_mask &
            CAM_QCOM_FEATURE_STILLMORE) == 0) {
        LOGD("Stillmore is not supported");
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_STILL_MORE);
    const char *prev_str = get(KEY_QC_STILL_MORE);
    LOGH("str =%s & prev_str =%s", str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL || strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setStillMore(str);
        }
    }
    return NO_ERROR;
}

#ifdef TARGET_TS_MAKEUP

/*===========================================================================
 * FUNCTION   : setTsMakeup
 *
 * DESCRIPTION: set setTsMakeup from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setTsMakeup(const QCameraParameters& params)
{
    const char *str = params.get(KEY_TS_MAKEUP);
    const char *prev_str = get(KEY_TS_MAKEUP);
    LOGH("str =%s & prev_str =%s", str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL || strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            set(KEY_TS_MAKEUP, str);
        }
        str = params.get(KEY_TS_MAKEUP_WHITEN);
        prev_str = get(KEY_TS_MAKEUP_WHITEN);
        if (str != NULL) {
            if (prev_str == NULL || strcmp(str, prev_str) != 0) {
                set(KEY_TS_MAKEUP_WHITEN, str);
            }
        }
        str = params.get(KEY_TS_MAKEUP_CLEAN);
        prev_str = get(KEY_TS_MAKEUP_CLEAN);
        if (str != NULL) {
            if (prev_str == NULL || strcmp(str, prev_str) != 0) {
                set(KEY_TS_MAKEUP_CLEAN, str);
            }
        }
    }
    return NO_ERROR;
}

#endif

/*===========================================================================
 * FUNCTION   : setRedeyeReduction
 *
 * DESCRIPTION: set red eye reduction setting from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setRedeyeReduction(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_REDEYE_REDUCTION);
    const char *prev_str = get(KEY_QC_REDEYE_REDUCTION);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setRedeyeReduction(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setGpsLocation
 *
 * DESCRIPTION: set GPS location information from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setGpsLocation(const QCameraParameters& params)
{
    const char *method = params.get(KEY_GPS_PROCESSING_METHOD);
    if (method) {
        set(KEY_GPS_PROCESSING_METHOD, method);
    }else {
        remove(KEY_GPS_PROCESSING_METHOD);
    }

    const char *latitude = params.get(KEY_GPS_LATITUDE);
    if (latitude) {
        set(KEY_GPS_LATITUDE, latitude);
    }else {
        remove(KEY_GPS_LATITUDE);
    }

    const char *latitudeRef = params.get(KEY_QC_GPS_LATITUDE_REF);
    if (latitudeRef) {
        set(KEY_QC_GPS_LATITUDE_REF, latitudeRef);
    }else {
        remove(KEY_QC_GPS_LATITUDE_REF);
    }

    const char *longitude = params.get(KEY_GPS_LONGITUDE);
    if (longitude) {
        set(KEY_GPS_LONGITUDE, longitude);
    }else {
        remove(KEY_GPS_LONGITUDE);
    }

    const char *longitudeRef = params.get(KEY_QC_GPS_LONGITUDE_REF);
    if (longitudeRef) {
        set(KEY_QC_GPS_LONGITUDE_REF, longitudeRef);
    }else {
        remove(KEY_QC_GPS_LONGITUDE_REF);
    }

    const char *altitudeRef = params.get(KEY_QC_GPS_ALTITUDE_REF);
    if (altitudeRef) {
        set(KEY_QC_GPS_ALTITUDE_REF, altitudeRef);
    }else {
        remove(KEY_QC_GPS_ALTITUDE_REF);
    }

    const char *altitude = params.get(KEY_GPS_ALTITUDE);
    if (altitude) {
        set(KEY_GPS_ALTITUDE, altitude);
    }else {
        remove(KEY_GPS_ALTITUDE);
    }

    const char *status = params.get(KEY_QC_GPS_STATUS);
    if (status) {
        set(KEY_QC_GPS_STATUS, status);
    } else {
        remove(KEY_QC_GPS_STATUS);
    }

    const char *timestamp = params.get(KEY_GPS_TIMESTAMP);
    if (timestamp) {
        set(KEY_GPS_TIMESTAMP, timestamp);
    }else {
        remove(KEY_GPS_TIMESTAMP);
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setNumOfSnapshot
 *
 * DESCRIPTION: set number of snapshot per shutter from user setting
 *
 * PARAMETERS : none
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setNumOfSnapshot()
{
    int nBurstNum = 1;
    int nExpnum = 0;

    const char *bracket_str = get(KEY_QC_AE_BRACKET_HDR);
    if (bracket_str != NULL && strlen(bracket_str) > 0) {
        int value = lookupAttr(BRACKETING_MODES_MAP, PARAM_MAP_SIZE(BRACKETING_MODES_MAP),
                bracket_str);
        switch (value) {
        case CAM_EXP_BRACKETING_ON:
            {
                nExpnum = 0;
                const char *str_val = get(KEY_QC_CAPTURE_BURST_EXPOSURE);
                if ((str_val != NULL) && (strlen(str_val) > 0)) {
                    char prop[PROPERTY_VALUE_MAX];
                    memset(prop, 0, sizeof(prop));
                    strlcpy(prop, str_val, PROPERTY_VALUE_MAX);
                    char *saveptr = NULL;
                    char *token = strtok_r(prop, ",", &saveptr);
                    while (token != NULL) {
                        token = strtok_r(NULL, ",", &saveptr);
                        nExpnum++;
                    }
                }
                if (nExpnum == 0) {
                    nExpnum = 1;
                }
            }
            break;
        default:
            nExpnum = 1 + getNumOfExtraHDROutBufsIfNeeded();
            break;
        }
    }

    if (isUbiRefocus()) {
        nBurstNum = m_pCapability->refocus_af_bracketing_need.output_count + 1;
    }

    LOGH("nBurstNum = %d, nExpnum = %d", nBurstNum, nExpnum);
    set(KEY_QC_NUM_SNAPSHOT_PER_SHUTTER, nBurstNum * nExpnum);
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setRecordingHint
 *
 * DESCRIPTION: set recording hint value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setRecordingHint(const QCameraParameters& params)
{
    const char * str = params.get(KEY_RECORDING_HINT);
    const char *prev_str = get(KEY_RECORDING_HINT);
    if (str != NULL) {
        if (prev_str == NULL || strcmp(str, prev_str) != 0) {
            int32_t value = lookupAttr(TRUE_FALSE_MODES_MAP, PARAM_MAP_SIZE(TRUE_FALSE_MODES_MAP),
                    str);
            if(value != NAME_NOT_FOUND){
                updateParamEntry(KEY_RECORDING_HINT, str);
                setRecordingHintValue(value);
                if (getFaceDetectionOption() == true) {
                    if (!fdModeInVideo()) {
                        setFaceDetection(value > 0 ? false : true, false);
                    } else {
                        setFaceDetection(true, false);
                    }
                }
                if (m_bDISEnabled) {
                    LOGH("Setting DIS value again");
                    setDISValue(VALUE_ENABLE);
                }
                return NO_ERROR;
            } else {
                LOGE("Invalid recording hint value: %s", str);
                return BAD_VALUE;
            }
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setNoDisplayMode
 *
 * DESCRIPTION: set no display mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setNoDisplayMode(const QCameraParameters& params)
{
    const char *str_val  = params.get(KEY_QC_NO_DISPLAY_MODE);
    const char *prev_str = get(KEY_QC_NO_DISPLAY_MODE);
    char prop[PROPERTY_VALUE_MAX];
    LOGD("str_val: %s, prev_str: %s", str_val, prev_str);

    // Aux Camera Mode, set no display mode
    if (m_relCamSyncInfo.mode == CAM_MODE_SECONDARY) {
        if (!m_bNoDisplayMode) {
            set(KEY_QC_NO_DISPLAY_MODE, 1);
            m_bNoDisplayMode = true;
            m_bNeedRestart = true;
        }
        return NO_ERROR;
    }

    if(str_val && strlen(str_val) > 0) {
        if (prev_str == NULL || strcmp(str_val, prev_str) != 0) {
            m_bNoDisplayMode = atoi(str_val);
            set(KEY_QC_NO_DISPLAY_MODE, str_val);
            m_bNeedRestart = true;
        }
    } else {
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.no-display", prop, "0");
        m_bNoDisplayMode = atoi(prop);
    }
    LOGH("Param m_bNoDisplayMode = %d", m_bNoDisplayMode);
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setZslMode
 *
 * DESCRIPTION: set ZSL mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setZslMode(const QCameraParameters& params)
{
    const char *str_val  = params.get(KEY_QC_ZSL);
    const char *prev_val  = get(KEY_QC_ZSL);
    int32_t rc = NO_ERROR;

    if(m_bForceZslMode) {
        if (!m_bZslMode) {
            // Force ZSL mode to ON
            set(KEY_QC_ZSL, VALUE_ON);
            setZslMode(TRUE);
            LOGH("ZSL Mode forced to be enabled");
        }
    } else if (str_val != NULL) {
        if (prev_val == NULL || strcmp(str_val, prev_val) != 0) {
            int32_t value = lookupAttr(ON_OFF_MODES_MAP, PARAM_MAP_SIZE(ON_OFF_MODES_MAP),
                    str_val);
            if (value != NAME_NOT_FOUND) {
                set(KEY_QC_ZSL, str_val);
                rc = setZslMode(value);
                // ZSL mode changed, need restart preview
                m_bNeedRestart = true;
            } else {
                LOGE("Invalid ZSL mode value: %s", str_val);
                rc = BAD_VALUE;
            }
        }
    }
    return rc;
}

/*===========================================================================
 * FUNCTION   : setZslMode
 *
 * DESCRIPTION: set ZSL mode from user setting
 *
 * PARAMETERS :
 *   @value  : ZSL mode value
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setZslMode(bool value)
{
    int32_t rc = NO_ERROR;
    if(m_bForceZslMode) {
        if (!m_bZslMode) {
            // Force ZSL mode to ON
            set(KEY_QC_ZSL, VALUE_ON);
            m_bZslMode_new = true;
            m_bZslMode = true;
            m_bNeedRestart = true;

            int32_t value = m_bForceZslMode;
            if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_ZSL_MODE, value)) {
                rc = BAD_VALUE;
            }

            LOGI("ZSL Mode forced to be enabled");
        }
    } else {
        LOGI("ZSL Mode  -> %s", m_bZslMode_new ? "Enabled" : "Disabled");
        m_bZslMode_new = (value > 0)? true : false;
        if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_ZSL_MODE, value)) {
            rc = BAD_VALUE;
        }
    }
    LOGH("enabled: %d rc = %d", m_bZslMode_new, rc);
    return rc;
}

/*===========================================================================
 * FUNCTION   : updateZSLModeValue
 *
 * DESCRIPTION: update zsl mode value locally and to daemon
 *
 * PARAMETERS :
 *   @value   : zsl mode value
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::updateZSLModeValue(bool value)
{
    int32_t rc = NO_ERROR;
    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        LOGE("Failed to initialize group update table");
        return BAD_TYPE;
    }

    rc = setZslMode(value);
    if (rc != NO_ERROR) {
        LOGE("Failed to ZSL value");
        return rc;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        LOGE("Failed to update recording hint");
        return rc;
    }

    return rc;
}

/*===========================================================================
 * FUNCTION   : setWaveletDenoise
 *
 * DESCRIPTION: set wavelet denoise value from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setWaveletDenoise(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_DENOISE);
    const char *prev_str = get(KEY_QC_DENOISE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setWaveletDenoise(str);
        }
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setTemporalDenoise
 *
 * DESCRIPTION: set temporal denoise value from properties
 *
 * PARAMETERS : none
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setTemporalDenoise(const QCameraParameters& params)
{
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_CPP_TNR) == 0) {
        LOGH("TNR is not supported");
        return NO_ERROR;
    }

    const char *str = params.get(KEY_QC_TNR_MODE);
    const char *prev_str = get(KEY_QC_TNR_MODE);
    const char *video_str = params.get(KEY_QC_VIDEO_TNR_MODE);
    const char *video_prev_str = get(KEY_QC_VIDEO_TNR_MODE);
    char video_value[PROPERTY_VALUE_MAX];
    char preview_value[PROPERTY_VALUE_MAX];
    bool prev_video_tnr = m_bTNRVideoOn;
    bool prev_preview_tnr = m_bTNRPreviewOn;
    bool prev_snap_tnr = m_bTNRSnapshotOn;

    char value[PROPERTY_VALUE_MAX];
    memset(value, 0, sizeof(value));
    property_get("persist.camera.tnr_cds", value, "0");
    uint8_t tnr_cds = (uint8_t)atoi(value);

    if (m_bRecordingHint_new == true) {
        if (video_str) {
            if ((video_prev_str == NULL) || (strcmp(video_str, video_prev_str) != 0)) {
                if (!strcmp(video_str, VALUE_ON)) {
                    m_bTNRVideoOn = true;
                    m_bTNRPreviewOn = true;
                } else {
                    m_bTNRVideoOn = false;
                    m_bTNRPreviewOn = false;
                }
                updateParamEntry(KEY_QC_VIDEO_TNR_MODE, video_str);
            } else {
                return NO_ERROR;
            }
        }
    } else {
        if (str) {
            if ((prev_str == NULL) || (strcmp(str, prev_str) != 0)) {
                if (!strcmp(str, VALUE_ON)) {
                    m_bTNRPreviewOn = true;
                } else {
                    m_bTNRPreviewOn = false;
                }
                updateParamEntry(KEY_QC_TNR_MODE, str);
            } else {
                return NO_ERROR;
            }
        }
    }

    //Read setprops only if UI is not present or disabled.
    if ((m_bRecordingHint_new == true)
            && ((video_str == NULL)
            || (strcmp(video_str, VALUE_ON)))) {
        memset(video_value, 0, sizeof(video_value));
        property_get("persist.camera.tnr.video", video_value, VALUE_OFF);
        if (!strcmp(video_value, VALUE_ON)) {
            m_bTNRVideoOn = true;
        } else {
            m_bTNRVideoOn = false;
        }
        updateParamEntry(KEY_QC_VIDEO_TNR_MODE, video_value);

        memset(preview_value, 0, sizeof(preview_value));
        property_get("persist.camera.tnr.preview", preview_value, VALUE_OFF);
        if (!strcmp(preview_value, VALUE_ON)) {
            m_bTNRPreviewOn = true;
        } else {
            m_bTNRPreviewOn = false;
        }
        updateParamEntry(KEY_QC_TNR_MODE, preview_value);
    } else if ((m_bRecordingHint_new != true)
            && ((str == NULL) || (strcmp(str, VALUE_ON)))) {
        memset(preview_value, 0, sizeof(preview_value));
        property_get("persist.camera.tnr.preview", preview_value, VALUE_OFF);
        if (!strcmp(preview_value, VALUE_ON)) {
            m_bTNRPreviewOn = true;
        } else {
            m_bTNRPreviewOn = false;
        }
        updateParamEntry(KEY_QC_TNR_MODE, preview_value);
    }

    memset(value, 0, sizeof(value));
    property_get("persist.camera.tnr.snapshot", value, VALUE_OFF);
    if (!strcmp(value, VALUE_ON)) {
        m_bTNRSnapshotOn = true;
        LOGD("TNR enabled for SNAPSHOT stream");
    } else {
        m_bTNRSnapshotOn = false;
    }

    cam_denoise_param_t temp;
    memset(&temp, 0, sizeof(temp));
    if (m_bTNRVideoOn || m_bTNRPreviewOn || m_bTNRSnapshotOn) {
        temp.denoise_enable = 1;
        temp.process_plates = getDenoiseProcessPlate(
                CAM_INTF_PARM_TEMPORAL_DENOISE);

        if (!tnr_cds) {
            int32_t cds_mode = lookupAttr(CDS_MODES_MAP,
                    PARAM_MAP_SIZE(CDS_MODES_MAP), CDS_MODE_OFF);

            if (cds_mode != NAME_NOT_FOUND) {
                updateParamEntry(KEY_QC_VIDEO_CDS_MODE, CDS_MODE_OFF);
                if (m_bTNRPreviewOn) {
                    updateParamEntry(KEY_QC_CDS_MODE, CDS_MODE_OFF);
                }
                if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf,
                        CAM_INTF_PARM_CDS_MODE, cds_mode)) {
                    LOGE("Failed CDS MODE to update table");
                    return BAD_VALUE;
                }
                LOGD("CDS is set to = %s when TNR is enabled",
                         CDS_MODE_OFF);
                mCds_mode = cds_mode;
            } else {
                LOGE("Invalid argument for video CDS MODE %d",
                         cds_mode);
            }
        } else {
            LOGH("Enabled TNR with CDS");
        }
    }

    if ((m_bTNRVideoOn != prev_video_tnr)
            || (m_bTNRPreviewOn != prev_preview_tnr)
            || (prev_snap_tnr != m_bTNRSnapshotOn)) {
        LOGD("TNR enabled = %d, plates = %d",
                temp.denoise_enable, temp.process_plates);
        if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf,
                CAM_INTF_PARM_TEMPORAL_DENOISE, temp)) {
            return BAD_VALUE;
        }
    }

    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setCameraMode
 *
 * DESCRIPTION: set camera mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setCameraMode(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_CAMERA_MODE);
    if (str != NULL) {
        set(KEY_QC_CAMERA_MODE, str);
    } else {
        remove(KEY_QC_CAMERA_MODE);
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setSceneSelectionMode
 *
 * DESCRIPTION: set scene selection mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setSceneSelectionMode(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_SCENE_SELECTION);
    const char *prev_str = get(KEY_QC_SCENE_SELECTION);
    if (NULL != str) {
        if ((NULL == prev_str) || (strcmp(str, prev_str) != 0)) {
            int32_t value = lookupAttr(ENABLE_DISABLE_MODES_MAP,
                    PARAM_MAP_SIZE(ENABLE_DISABLE_MODES_MAP), str);
            if (value != NAME_NOT_FOUND) {
                LOGD("Setting selection value %s", str);
                if (value && m_bZslMode_new) {
                    updateParamEntry(KEY_QC_SCENE_SELECTION, str);
                    m_bNeedRestart = true;
                    m_bSceneSelection = true;
                } else if (!value) {
                    updateParamEntry(KEY_QC_SCENE_SELECTION, str);
                    m_bNeedRestart = true;
                    m_bSceneSelection = false;
                } else {
                    LOGE("Trying to enable scene selection in non ZSL mode!!!");
                    return BAD_VALUE;
                }
            } else {
                LOGE("Trying to configure invalid scene selection value: %s",
                        str);
                return BAD_VALUE;
            }
        }
    }

    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setSelectedScene
 *
 * DESCRIPTION: select specific scene
 *
 * PARAMETERS :
 *   @scene   : scene mode
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setSelectedScene(cam_scene_mode_type scene)
{
    Mutex::Autolock l(m_SceneSelectLock);
    m_SelectedScene = scene;
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : getSelectedScene
 *
 * DESCRIPTION: get selected scene
 *
 * PARAMETERS :
 *
 * RETURN     : currently selected scene
 *==========================================================================*/
cam_scene_mode_type QCameraParameters::getSelectedScene()
{
    Mutex::Autolock l(m_SceneSelectLock);
    return m_SelectedScene;
}

/*==========================================================
 * FUNCTION   : setRdiMode
 *
 * DESCRIPTION: set Rdi mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *===========================================================*/
int32_t QCameraParameters::setRdiMode(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_RDI_MODE);
    const char *prev_str = get(KEY_QC_RDI_MODE);
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));

    property_get("persist.camera.rdi.mode", prop, VALUE_DISABLE);
    if ((str != NULL) && (prev_str == NULL || strcmp(str, prev_str) != 0)) {
        LOGD("RDI mode set to %s", str);
        setRdiMode(str);
    } else if (prev_str == NULL || strcmp(prev_str, prop) != 0 ) {
        LOGD("RDI mode set to prop: %s", prop);
        setRdiMode(prop);
    }
    return NO_ERROR;
}

/*==========================================================
 * FUNCTION   : setSecureMode
 *
 * DESCRIPTION: set secure mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *===========================================================*/

int32_t QCameraParameters::setSecureMode(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_SECURE_MODE);
    const char *prev_str = get(KEY_QC_SECURE_MODE);
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));

    property_get("persist.camera.secure.mode", prop, VALUE_DISABLE);
    if ((str != NULL) && (prev_str == NULL || strcmp(str, prev_str) != 0)) {
        LOGD("Secure mode set to KEY: %s", str);
        setSecureMode(str);
    } else if (prev_str == NULL || strcmp(prev_str, prop) != 0 ) {
        LOGD("Secure mode set to prop: %s", prop);
        setSecureMode(prop);
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setZslAttributes
 *
 * DESCRIPTION: set ZSL related attributes from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setZslAttributes(const QCameraParameters& params)
{
    // TODO: may switch to pure param instead of sysprop
    char prop[PROPERTY_VALUE_MAX];

    const char *str = params.get(KEY_QC_ZSL_BURST_INTERVAL);
    if (str != NULL) {
        set(KEY_QC_ZSL_BURST_INTERVAL, str);
    } else {
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.zsl.interval", prop, "1");
        set(KEY_QC_ZSL_BURST_INTERVAL, prop);
        LOGH("burst interval: %s", prop);
    }

    str = params.get(KEY_QC_ZSL_BURST_LOOKBACK);
    if (str != NULL) {
        set(KEY_QC_ZSL_BURST_LOOKBACK, str);
    } else {
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.zsl.backlookcnt", prop, "2");
        uint32_t look_back_cnt = atoi(prop);
        if (m_bFrameSyncEnabled) {
            look_back_cnt += EXTRA_FRAME_SYNC_BUFFERS;
        }
        set(KEY_QC_ZSL_BURST_LOOKBACK, look_back_cnt);
        LOGH("look back count: %s", prop);
    }

    str = params.get(KEY_QC_ZSL_QUEUE_DEPTH);
    if (str != NULL) {
        set(KEY_QC_ZSL_QUEUE_DEPTH, str);
    } else {
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.zsl.queuedepth", prop, "2");
        uint32_t queue_depth = atoi(prop);
        if (m_bFrameSyncEnabled) {
            queue_depth += EXTRA_FRAME_SYNC_BUFFERS;
        }
        set(KEY_QC_ZSL_QUEUE_DEPTH, queue_depth);
        LOGH("queue depth: %s", prop);
    }

    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setFlip
 *
 * DESCRIPTION: set preview/ video/ picture flip mode from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setFlip(const QCameraParameters& params)
{
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_FLIP) == 0) {
        LOGH("flip is not supported.");
        return NO_ERROR;
    }

    //check preview flip setting
    const char *str = params.get(KEY_QC_PREVIEW_FLIP);
    const char *prev_val = get(KEY_QC_PREVIEW_FLIP);
    if(str != NULL){
        if (prev_val == NULL || strcmp(str, prev_val) != 0) {
            int32_t value = lookupAttr(FLIP_MODES_MAP, PARAM_MAP_SIZE(FLIP_MODES_MAP), str);
            if(value != NAME_NOT_FOUND){
                set(KEY_QC_PREVIEW_FLIP, str);
                m_bPreviewFlipChanged = true;
            }
        }
    }

    // check video filp setting
    str = params.get(KEY_QC_VIDEO_FLIP);
    prev_val = get(KEY_QC_VIDEO_FLIP);
    if(str != NULL){
        if (prev_val == NULL || strcmp(str, prev_val) != 0) {
            int32_t value = lookupAttr(FLIP_MODES_MAP, PARAM_MAP_SIZE(FLIP_MODES_MAP), str);
            if(value != NAME_NOT_FOUND){
                set(KEY_QC_VIDEO_FLIP, str);
                m_bVideoFlipChanged = true;
            }
        }
    }

    // check picture filp setting
    str = params.get(KEY_QC_SNAPSHOT_PICTURE_FLIP);
    prev_val = get(KEY_QC_SNAPSHOT_PICTURE_FLIP);
    if(str != NULL){
        if (prev_val == NULL || strcmp(str, prev_val) != 0) {
            int32_t value = lookupAttr(FLIP_MODES_MAP, PARAM_MAP_SIZE(FLIP_MODES_MAP), str);
            if(value != NAME_NOT_FOUND){
                set(KEY_QC_SNAPSHOT_PICTURE_FLIP, str);
                m_bSnapshotFlipChanged = true;
            }
        }
    }

    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setSnapshotFDReq
 *
 * DESCRIPTION: set requirement of Face Detection Metadata in Snapshot mode.
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setSnapshotFDReq(const QCameraParameters& params)
{
    char prop[PROPERTY_VALUE_MAX];
    const char *str = params.get(KEY_QC_SNAPSHOT_FD_DATA);

    if(str != NULL){
        set(KEY_QC_SNAPSHOT_FD_DATA, str);
    }else{
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.snapshot.fd", prop, "0");
        set(KEY_QC_SNAPSHOT_FD_DATA, prop);
    }
    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setMobicat
 *
 * DESCRIPTION: set Mobicat on/off.
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setMobicat(const QCameraParameters& )
{
    char value [PROPERTY_VALUE_MAX];
    property_get("persist.camera.mobicat", value, "0");
    int32_t ret = NO_ERROR;
    uint8_t enableMobi = (uint8_t)atoi(value);

    if (enableMobi) {
        tune_cmd_t tune_cmd;
        tune_cmd.type = 2;
        tune_cmd.module = 0;
        tune_cmd.value = 1;
        if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_SET_VFE_COMMAND, tune_cmd)) {
            return BAD_VALUE;
        }
        if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_SET_PP_COMMAND, tune_cmd)) {
            ret = BAD_VALUE;
        }
    }
    m_MobiMask = enableMobi;

    return ret;
}

/*===========================================================================
 * FUNCTION   : setLongshotParam
 *
 * DESCRIPTION: set Longshot on/off.
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setLongshotParam(const QCameraParameters& params)
{
    const char *str = params.get(KEY_QC_LONG_SHOT);
    const char *prev_str = get(KEY_QC_LONG_SHOT);

    if (str != NULL) {
        if (prev_str == NULL || strcmp(str, prev_str) != 0) {
            set(KEY_QC_LONG_SHOT, str);
            if (prev_str && !strcmp(str, "off") && !strcmp(prev_str, "on")) {
                // We restart here, to reset the FPS and no
                // of buffers as per the requirement of single snapshot usecase.
                // Here restart happens when continuous shot is changed to off from on.
                // In case of continuous shot on, restart is taken care when actual
                // longshot command is triggered through sendCommand.
                m_bNeedRestart = true;
            }
        }
    }

    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : checkFeatureConcurrency
 *
 * DESCRIPTION: check if there is a feature concurrency issue with advanced
 *              camera features
 *
 * PARAMETERS : None
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::checkFeatureConcurrency()
{
    int32_t rc = NO_ERROR;
    uint32_t advancedFeatEnableBit = 0;

    if (isStillMoreEnabled()) {
        advancedFeatEnableBit |= CAM_QCOM_FEATURE_STILLMORE;
    }
    if (isHDREnabled()) {
        advancedFeatEnableBit |= CAM_QCOM_FEATURE_HDR;
    }
    if (isChromaFlashEnabled()) {
        advancedFeatEnableBit |= CAM_QCOM_FEATURE_CHROMA_FLASH;
    }
    if (isUbiFocusEnabled()) {
        advancedFeatEnableBit |= CAM_QCOM_FEATURE_UBIFOCUS;
    }
    if (isTruePortraitEnabled()) {
        advancedFeatEnableBit |= CAM_QCOM_FEATURE_TRUEPORTRAIT;
    }
    if (isOptiZoomEnabled()) {
        advancedFeatEnableBit |= CAM_QCOM_FEATURE_OPTIZOOM;
    }
    if (isUbiRefocus()) {
        advancedFeatEnableBit |= CAM_QCOM_FEATURE_REFOCUS;
    }

   if (m_bLongshotEnabled && advancedFeatEnableBit) {
        LOGE("Failed Longshot mode bit 0x%x",
                    advancedFeatEnableBit);
        rc = BAD_TYPE;
        return rc;
    }

    if(m_bRecordingHint_new) {
        advancedFeatEnableBit &= ~CAM_QCOM_FEATURE_STILLMORE;

        if (advancedFeatEnableBit) {
            LOGE("Failed recording mode bit 0x%x",
                    advancedFeatEnableBit);
            rc = BAD_TYPE;
        }
    } else if (m_bZslMode_new) {
        /* ZSL mode check if 2 bits are set */
        if (advancedFeatEnableBit & (advancedFeatEnableBit - 1)) {
            LOGE("Failed ZSL mode bit 0x%x", advancedFeatEnableBit);
            rc = BAD_TYPE;
        }
    } else { /* non-ZSL mode */
        advancedFeatEnableBit &= ~CAM_QCOM_FEATURE_HDR;

        /* non-ZSL mode check if 1 bit is set */
        if (advancedFeatEnableBit) {
            LOGE("Failed non-ZSL mode bit 0x%x", advancedFeatEnableBit);
            rc = BAD_TYPE;
        }
    }
    LOGI("Advance feature enabled 0x%x", advancedFeatEnableBit);
    return rc;
}

/*===========================================================================
 * FUNCTION   : updateParameters
 *
 * DESCRIPTION: update parameters from user setting
 *
 * PARAMETERS :
 *   @params  : user setting parameters
 *   @needRestart : [output] if preview need restart upon setting changes
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::updateParameters(const String8& p,
        bool &needRestart)
{
    int32_t final_rc = NO_ERROR;
    int32_t rc;
    m_bNeedRestart = false;
    QCameraParameters params(p);

    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        LOGE("Failed to initialize group update table");
        rc = BAD_TYPE;
        goto UPDATE_PARAM_DONE;
    }

    if ((rc = setPreviewSize(params)))                  final_rc = rc;
    if ((rc = setVideoSize(params)))                    final_rc = rc;
    if ((rc = setPictureSize(params)))                  final_rc = rc;
    if ((rc = setPreviewFormat(params)))                final_rc = rc;
    if ((rc = setPictureFormat(params)))                final_rc = rc;
    if ((rc = setJpegQuality(params)))                  final_rc = rc;
    if ((rc = setOrientation(params)))                  final_rc = rc;
    if ((rc = setRotation(params)))                     final_rc = rc;
    if ((rc = setVideoRotation(params)))                final_rc = rc;
    if ((rc = setNoDisplayMode(params)))                final_rc = rc;
    if ((rc = setZslMode(params)))                      final_rc = rc;
    if ((rc = setZslAttributes(params)))                final_rc = rc;
    if ((rc = setCameraMode(params)))                   final_rc = rc;
    if ((rc = setSceneSelectionMode(params)))           final_rc = rc;
    if ((rc = setRecordingHint(params)))                final_rc = rc;
    if ((rc = setRdiMode(params)))                      final_rc = rc;
    if ((rc = setSecureMode(params)))                   final_rc = rc;
    if ((rc = setPreviewFrameRate(params)))             final_rc = rc;
    if ((rc = setPreviewFpsRange(params)))              final_rc = rc;
    if ((rc = setAutoExposure(params)))                 final_rc = rc;
    if ((rc = setEffect(params)))                       final_rc = rc;
    if ((rc = setBrightness(params)))                   final_rc = rc;
    if ((rc = setZoom(params)))                         final_rc = rc;
    if ((rc = setSharpness(params)))                    final_rc = rc;
    if ((rc = setSaturation(params)))                   final_rc = rc;
    if ((rc = setContrast(params)))                     final_rc = rc;
    if ((rc = setFocusMode(params)))                    final_rc = rc;
    if ((rc = setISOValue(params)))                     final_rc = rc;
    if ((rc = setContinuousISO(params)))                final_rc = rc;
    if ((rc = setExposureTime(params)))                 final_rc = rc;
    if ((rc = setSkinToneEnhancement(params)))          final_rc = rc;
    if ((rc = setFlash(params)))                        final_rc = rc;
    if ((rc = setAecLock(params)))                      final_rc = rc;
    if ((rc = setAwbLock(params)))                      final_rc = rc;
    if ((rc = setLensShadeValue(params)))               final_rc = rc;
    if ((rc = setMCEValue(params)))                     final_rc = rc;
    if ((rc = setDISValue(params)))                     final_rc = rc;
    if ((rc = setAntibanding(params)))                  final_rc = rc;
    if ((rc = setExposureCompensation(params)))         final_rc = rc;
    if ((rc = setWhiteBalance(params)))                 final_rc = rc;
    if ((rc = setHDRMode(params)))                      final_rc = rc;
    if ((rc = setHDRNeed1x(params)))                    final_rc = rc;
    if ((rc = setManualWhiteBalance(params)))           final_rc = rc;
    if ((rc = setSceneMode(params)))                    final_rc = rc;
    if ((rc = setFocusAreas(params)))                   final_rc = rc;
    if ((rc = setFocusPosition(params)))                final_rc = rc;
    if ((rc = setMeteringAreas(params)))                final_rc = rc;
    if ((rc = setSelectableZoneAf(params)))             final_rc = rc;
    if ((rc = setRedeyeReduction(params)))              final_rc = rc;
    if ((rc = setAEBracket(params)))                    final_rc = rc;
    if ((rc = setAutoHDR(params)))                      final_rc = rc;
    if ((rc = setGpsLocation(params)))                  final_rc = rc;
    if ((rc = setWaveletDenoise(params)))               final_rc = rc;
    if ((rc = setFaceRecognition(params)))              final_rc = rc;
    if ((rc = setFlip(params)))                         final_rc = rc;
    if ((rc = setVideoHDR(params)))                     final_rc = rc;
    if ((rc = setVtEnable(params)))                     final_rc = rc;
    if ((rc = setAFBracket(params)))                    final_rc = rc;
    if ((rc = setReFocus(params)))                      final_rc = rc;
    if ((rc = setChromaFlash(params)))                  final_rc = rc;
    if ((rc = setTruePortrait(params)))                 final_rc = rc;
    if ((rc = setOptiZoom(params)))                     final_rc = rc;
    if ((rc = setBurstLEDOnPeriod(params)))             final_rc = rc;
    if ((rc = setRetroActiveBurstNum(params)))          final_rc = rc;
    if ((rc = setSnapshotFDReq(params)))                final_rc = rc;
    if ((rc = setTintlessValue(params)))                final_rc = rc;
    if ((rc = setCDSMode(params)))                      final_rc = rc;
    if ((rc = setTemporalDenoise(params)))              final_rc = rc;
    if ((rc = setCacheVideoBuffers(params)))            final_rc = rc;
    if ((rc = setInitialExposureIndex(params)))         final_rc = rc;
    if ((rc = setInstantCapture(params)))               final_rc = rc;
    if ((rc = setInstantAEC(params)))                   final_rc = rc;

    // update live snapshot size after all other parameters are set
    if ((rc = setLiveSnapshotSize(params)))             final_rc = rc;
    if ((rc = setJpegThumbnailSize(params)))            final_rc = rc;
    if ((rc = setStatsDebugMask()))                     final_rc = rc;
    if ((rc = setPAAF()))                               final_rc = rc;
    if ((rc = setMobicat(params)))                      final_rc = rc;
    if ((rc = setSeeMore(params)))                      final_rc = rc;
    if ((rc = setStillMore(params)))                    final_rc = rc;
    if ((rc = setCustomParams(params)))                 final_rc = rc;
    if ((rc = setNoiseReductionMode(params)))           final_rc = rc;

    if ((rc = setLongshotParam(params)))                final_rc = rc;
    if ((rc = setLedCalibration(params)))               final_rc = rc;

    setQuadraCfa(params);
    setVideoBatchSize();
    setLowLightCapture();

    if ((rc = updateFlash(false)))                      final_rc = rc;
#ifdef TARGET_TS_MAKEUP
    if ((rc = setTsMakeup(params)))                     final_rc = rc;
#endif
    if ((rc = setAdvancedCaptureMode()))                final_rc = rc;
UPDATE_PARAM_DONE:
    needRestart = m_bNeedRestart;
    return final_rc;
}

/*===========================================================================
 * FUNCTION   : commitParameters
 *
 * DESCRIPTION: commit parameter changes to backend
 *
 * PARAMETERS : none
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::commitParameters()
{
    return commitSetBatch();
}

/*===========================================================================
 * FUNCTION   : initDefaultParameters
 *
 * DESCRIPTION: initialize default parameters for the first time
 *
 * PARAMETERS : none
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::initDefaultParameters()
{
    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        LOGE("Failed to initialize group update table");
        return BAD_TYPE;
    }
    int32_t hal_version = CAM_HAL_V1;
    ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_HAL_VERSION, hal_version);

    /*************************Initialize Values******************************/
    // Set read only parameters from camera capability
    set(KEY_SMOOTH_ZOOM_SUPPORTED,
        m_pCapability->smooth_zoom_supported? VALUE_TRUE : VALUE_FALSE);
    set(KEY_ZOOM_SUPPORTED,
        m_pCapability->zoom_supported? VALUE_TRUE : VALUE_FALSE);
    set(KEY_VIDEO_SNAPSHOT_SUPPORTED,
        m_pCapability->video_snapshot_supported? VALUE_TRUE : VALUE_FALSE);
    set(KEY_VIDEO_STABILIZATION_SUPPORTED,
        m_pCapability->video_stablization_supported? VALUE_TRUE : VALUE_FALSE);
    set(KEY_AUTO_EXPOSURE_LOCK_SUPPORTED,
        m_pCapability->auto_exposure_lock_supported? VALUE_TRUE : VALUE_FALSE);
    set(KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED,
        m_pCapability->auto_wb_lock_supported? VALUE_TRUE : VALUE_FALSE);
    set(KEY_MAX_NUM_DETECTED_FACES_HW, m_pCapability->max_num_roi);
    set(KEY_MAX_NUM_DETECTED_FACES_SW, m_pCapability->max_num_roi);
    set(KEY_QC_MAX_NUM_REQUESTED_FACES, m_pCapability->max_num_roi);
    // Set focal length, horizontal view angle, and vertical view angle
    setFloat(KEY_FOCAL_LENGTH, m_pCapability->focal_length);
    setFloat(KEY_HORIZONTAL_VIEW_ANGLE, m_pCapability->hor_view_angle);
    setFloat(KEY_VERTICAL_VIEW_ANGLE, m_pCapability->ver_view_angle);
    set(QCameraParameters::KEY_FOCUS_DISTANCES, "Infinity,Infinity,Infinity");
    set(KEY_QC_AUTO_HDR_SUPPORTED,
        (m_pCapability->auto_hdr_supported)? VALUE_TRUE : VALUE_FALSE);
    // Set supported preview sizes
    if (m_pCapability->preview_sizes_tbl_cnt > 0 &&
        m_pCapability->preview_sizes_tbl_cnt <= MAX_SIZES_CNT) {
        String8 previewSizeValues = createSizesString(
                m_pCapability->preview_sizes_tbl, m_pCapability->preview_sizes_tbl_cnt);
        set(KEY_SUPPORTED_PREVIEW_SIZES, previewSizeValues.string());
        LOGH("supported preview sizes: %s", previewSizeValues.string());
        // Set default preview size
        CameraParameters::setPreviewSize(m_pCapability->preview_sizes_tbl[0].width,
                                         m_pCapability->preview_sizes_tbl[0].height);
    } else {
        LOGW("supported preview sizes cnt is 0 or exceeds max!!!");
    }

    // Set supported video sizes
    if (m_pCapability->video_sizes_tbl_cnt > 0 &&
        m_pCapability->video_sizes_tbl_cnt <= MAX_SIZES_CNT) {
        String8 videoSizeValues = createSizesString(
                m_pCapability->video_sizes_tbl, m_pCapability->video_sizes_tbl_cnt);
        set(KEY_SUPPORTED_VIDEO_SIZES, videoSizeValues.string());
        LOGH("supported video sizes: %s", videoSizeValues.string());
        // Set default video size
        CameraParameters::setVideoSize(m_pCapability->video_sizes_tbl[0].width,
                                       m_pCapability->video_sizes_tbl[0].height);

        //Set preferred Preview size for video
        String8 vSize = createSizesString(&m_pCapability->preview_sizes_tbl[0], 1);
        set(KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO, vSize.string());
    } else {
        LOGW("supported video sizes cnt is 0 or exceeds max!!!");
    }

    // Set supported picture sizes
    if (m_pCapability->picture_sizes_tbl_cnt > 0 &&
        m_pCapability->picture_sizes_tbl_cnt <= MAX_SIZES_CNT) {
        String8 pictureSizeValues = createSizesString(
                m_pCapability->picture_sizes_tbl, m_pCapability->picture_sizes_tbl_cnt);
        set(KEY_SUPPORTED_PICTURE_SIZES, pictureSizeValues.string());
        LOGH("supported pic sizes: %s", pictureSizeValues.string());
        // Set default picture size to the smallest resolution
        CameraParameters::setPictureSize(
           m_pCapability->picture_sizes_tbl[m_pCapability->picture_sizes_tbl_cnt-1].width,
           m_pCapability->picture_sizes_tbl[m_pCapability->picture_sizes_tbl_cnt-1].height);
    } else {
        LOGW("supported picture sizes cnt is 0 or exceeds max!!!");
    }

    // Need check if scale should be enabled
    if (m_pCapability->scale_picture_sizes_cnt > 0 &&
        m_pCapability->scale_picture_sizes_cnt <= MAX_SCALE_SIZES_CNT){
        //get scale size, enable scaling. And re-set picture size table with scale sizes
        m_reprocScaleParam.setScaleEnable(true);
        int rc_s = m_reprocScaleParam.setScaleSizeTbl(
            m_pCapability->scale_picture_sizes_cnt, m_pCapability->scale_picture_sizes,
            m_pCapability->picture_sizes_tbl_cnt, m_pCapability->picture_sizes_tbl);
        if(rc_s == NO_ERROR){
            cam_dimension_t *totalSizeTbl = m_reprocScaleParam.getTotalSizeTbl();
            size_t totalSizeCnt = m_reprocScaleParam.getTotalSizeTblCnt();
            String8 pictureSizeValues = createSizesString(totalSizeTbl, totalSizeCnt);
            set(KEY_SUPPORTED_PICTURE_SIZES, pictureSizeValues.string());
            LOGH("scaled supported pic sizes: %s", pictureSizeValues.string());
        }else{
            m_reprocScaleParam.setScaleEnable(false);
            LOGW("reset scaled picture size table failed.");
        }
    }else{
        m_reprocScaleParam.setScaleEnable(false);
    }

    // Set supported thumbnail sizes
    String8 thumbnailSizeValues = createSizesString(
            THUMBNAIL_SIZES_MAP,
            PARAM_MAP_SIZE(THUMBNAIL_SIZES_MAP));
    set(KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, thumbnailSizeValues.string());
    // Set default thumnail size
    set(KEY_JPEG_THUMBNAIL_WIDTH, THUMBNAIL_SIZES_MAP[0].width);
    set(KEY_JPEG_THUMBNAIL_HEIGHT, THUMBNAIL_SIZES_MAP[0].height);

    // Set supported livesnapshot sizes
    if (m_pCapability->livesnapshot_sizes_tbl_cnt > 0 &&
        m_pCapability->livesnapshot_sizes_tbl_cnt <= MAX_SIZES_CNT) {
        String8 liveSnpashotSizeValues = createSizesString(
                m_pCapability->livesnapshot_sizes_tbl,
                m_pCapability->livesnapshot_sizes_tbl_cnt);
        set(KEY_QC_SUPPORTED_LIVESNAPSHOT_SIZES, liveSnpashotSizeValues.string());
        LOGD("supported live snapshot sizes: %s", liveSnpashotSizeValues.string());
        m_LiveSnapshotSize =
            m_pCapability->livesnapshot_sizes_tbl[m_pCapability->livesnapshot_sizes_tbl_cnt-1];
    }

    // Set supported preview formats
    String8 previewFormatValues = createValuesString(
            m_pCapability->supported_preview_fmts,
            m_pCapability->supported_preview_fmt_cnt,
            PREVIEW_FORMATS_MAP,
            PARAM_MAP_SIZE(PREVIEW_FORMATS_MAP));
    set(KEY_SUPPORTED_PREVIEW_FORMATS, previewFormatValues.string());
    // Set default preview format
    CameraParameters::setPreviewFormat(PIXEL_FORMAT_YUV420SP);

    // Set default Video Format as OPAQUE
    // Internally both Video and Camera subsystems use NV21_VENUS
    set(KEY_VIDEO_FRAME_FORMAT, PIXEL_FORMAT_ANDROID_OPAQUE);

    // Set supported picture formats
    String8 pictureTypeValues(PIXEL_FORMAT_JPEG);
    String8 str = createValuesString(
            m_pCapability->supported_raw_fmts,
            m_pCapability->supported_raw_fmt_cnt,
            PICTURE_TYPES_MAP,
            PARAM_MAP_SIZE(PICTURE_TYPES_MAP));
    if (str.string() != NULL) {
        pictureTypeValues.append(",");
        pictureTypeValues.append(str);
    }

    set(KEY_SUPPORTED_PICTURE_FORMATS, pictureTypeValues.string());
    // Set default picture Format
    CameraParameters::setPictureFormat(PIXEL_FORMAT_JPEG);
    // Set raw image size
    char raw_size_str[32];
    snprintf(raw_size_str, sizeof(raw_size_str), "%dx%d",
             m_pCapability->raw_dim[0].width, m_pCapability->raw_dim[0].height);
    set(KEY_QC_RAW_PICUTRE_SIZE, raw_size_str);
    LOGD("KEY_QC_RAW_PICUTRE_SIZE: w: %d, h: %d ",
       m_pCapability->raw_dim[0].width, m_pCapability->raw_dim[0].height);

    //set default jpeg quality and thumbnail quality
    set(KEY_JPEG_QUALITY, 85);
    set(KEY_JPEG_THUMBNAIL_QUALITY, 85);

    // Set FPS ranges
    if (m_pCapability->fps_ranges_tbl_cnt > 0 &&
        m_pCapability->fps_ranges_tbl_cnt <= MAX_SIZES_CNT) {
        int default_fps_index = 0;
        String8 fpsRangeValues = createFpsRangeString(m_pCapability->fps_ranges_tbl,
                                                      m_pCapability->fps_ranges_tbl_cnt,
                                                      default_fps_index);
        set(KEY_SUPPORTED_PREVIEW_FPS_RANGE, fpsRangeValues.string());

        int min_fps =
            int(m_pCapability->fps_ranges_tbl[default_fps_index].min_fps * 1000);
        int max_fps =
            int(m_pCapability->fps_ranges_tbl[default_fps_index].max_fps * 1000);
        m_default_fps_range = m_pCapability->fps_ranges_tbl[default_fps_index];
        //Set video fps same as preview fps
        setPreviewFpsRange(min_fps, max_fps, min_fps, max_fps);

        // Set legacy preview fps
        String8 fpsValues = createFpsString(m_pCapability->fps_ranges_tbl[default_fps_index]);
        set(KEY_SUPPORTED_PREVIEW_FRAME_RATES, fpsValues.string());
        LOGH("supported fps rates: %s", fpsValues.string());
        CameraParameters::setPreviewFrameRate(int(m_pCapability->fps_ranges_tbl[default_fps_index].max_fps));
    } else {
        LOGW("supported fps ranges cnt is 0 or exceeds max!!!");
    }

    // Set supported focus modes
    if (m_pCapability->supported_focus_modes_cnt > 0) {
        String8 focusModeValues = createValuesString(
                m_pCapability->supported_focus_modes,
                m_pCapability->supported_focus_modes_cnt,
                FOCUS_MODES_MAP,
                PARAM_MAP_SIZE(FOCUS_MODES_MAP));
        set(KEY_SUPPORTED_FOCUS_MODES, focusModeValues);

        // Set default focus mode and update corresponding parameter buf
        const char *focusMode = lookupNameByValue(FOCUS_MODES_MAP,
                PARAM_MAP_SIZE(FOCUS_MODES_MAP),
                m_pCapability->supported_focus_modes[0]);
        if (focusMode != NULL) {
            setFocusMode(focusMode);
        } else {
            setFocusMode(FOCUS_MODE_FIXED);
        }
    } else {
        LOGW("supported focus modes cnt is 0!!!");
    }

    // Set focus areas
    if (m_pCapability->max_num_focus_areas > MAX_ROI) {
        m_pCapability->max_num_focus_areas = MAX_ROI;
    }
    set(KEY_MAX_NUM_FOCUS_AREAS, m_pCapability->max_num_focus_areas);
    if (m_pCapability->max_num_focus_areas > 0) {
        setFocusAreas(DEFAULT_CAMERA_AREA);
    }

    // Set metering areas
    if (m_pCapability->max_num_metering_areas > MAX_ROI) {
        m_pCapability->max_num_metering_areas = MAX_ROI;
    }
    set(KEY_MAX_NUM_METERING_AREAS, m_pCapability->max_num_metering_areas);
    if (m_pCapability->max_num_metering_areas > 0) {
        setMeteringAreas(DEFAULT_CAMERA_AREA);
    }

    // set focus position, we should get them from m_pCapability
    m_pCapability->min_focus_pos[CAM_MANUAL_FOCUS_MODE_INDEX] = 0;
    m_pCapability->max_focus_pos[CAM_MANUAL_FOCUS_MODE_INDEX] = 1023;
    set(KEY_QC_MIN_FOCUS_POS_INDEX,
            (int) m_pCapability->min_focus_pos[CAM_MANUAL_FOCUS_MODE_INDEX]);
    set(KEY_QC_MAX_FOCUS_POS_INDEX,
            (int) m_pCapability->max_focus_pos[CAM_MANUAL_FOCUS_MODE_INDEX]);

    m_pCapability->min_focus_pos[CAM_MANUAL_FOCUS_MODE_DAC_CODE] = 0;
    m_pCapability->max_focus_pos[CAM_MANUAL_FOCUS_MODE_DAC_CODE] = 1023;
    set(KEY_QC_MIN_FOCUS_POS_DAC,
            (int) m_pCapability->min_focus_pos[CAM_MANUAL_FOCUS_MODE_DAC_CODE]);
    set(KEY_QC_MAX_FOCUS_POS_DAC,
            (int) m_pCapability->max_focus_pos[CAM_MANUAL_FOCUS_MODE_DAC_CODE]);

    m_pCapability->min_focus_pos[CAM_MANUAL_FOCUS_MODE_RATIO] = 0;
    m_pCapability->max_focus_pos[CAM_MANUAL_FOCUS_MODE_RATIO] = 100;
    set(KEY_QC_MIN_FOCUS_POS_RATIO,
            (int) m_pCapability->min_focus_pos[CAM_MANUAL_FOCUS_MODE_RATIO]);
    set(KEY_QC_MAX_FOCUS_POS_RATIO,
            (int) m_pCapability->max_focus_pos[CAM_MANUAL_FOCUS_MODE_RATIO]);

    m_pCapability->min_focus_pos[CAM_MANUAL_FOCUS_MODE_DIOPTER] = 0;
    if (m_pCapability->min_focus_distance > 0) {
        m_pCapability->max_focus_pos[CAM_MANUAL_FOCUS_MODE_DIOPTER] =
                m_pCapability->min_focus_distance;
    } else {
        m_pCapability->max_focus_pos[CAM_MANUAL_FOCUS_MODE_DIOPTER] = 0;
    }
    setFloat(KEY_QC_MIN_FOCUS_POS_DIOPTER,
            m_pCapability->min_focus_pos[CAM_MANUAL_FOCUS_MODE_DIOPTER]);
    setFloat(KEY_QC_MAX_FOCUS_POS_DIOPTER,
            m_pCapability->max_focus_pos[CAM_MANUAL_FOCUS_MODE_DIOPTER]);

    //set supported manual focus modes
    String8 manualFocusModes(VALUE_OFF);
    if (m_pCapability->supported_focus_modes_cnt > 1 &&
        m_pCapability->min_focus_distance > 0) {
        manualFocusModes.append(",");
        manualFocusModes.append(KEY_QC_FOCUS_SCALE_MODE);
        manualFocusModes.append(",");
        manualFocusModes.append(KEY_QC_FOCUS_DIOPTER_MODE);
    }
    set(KEY_QC_SUPPORTED_MANUAL_FOCUS_MODES, manualFocusModes.string());

    // Set Saturation
    set(KEY_QC_MIN_SATURATION, m_pCapability->saturation_ctrl.min_value);
    set(KEY_QC_MAX_SATURATION, m_pCapability->saturation_ctrl.max_value);
    set(KEY_QC_SATURATION_STEP, m_pCapability->saturation_ctrl.step);
    setSaturation(m_pCapability->saturation_ctrl.def_value);

    // Set Sharpness
    set(KEY_QC_MIN_SHARPNESS, m_pCapability->sharpness_ctrl.min_value);
    set(KEY_QC_MAX_SHARPNESS, m_pCapability->sharpness_ctrl.max_value);
    set(KEY_QC_SHARPNESS_STEP, m_pCapability->sharpness_ctrl.step);
    setSharpness(m_pCapability->sharpness_ctrl.def_value);

    // Set Contrast
    set(KEY_QC_MIN_CONTRAST, m_pCapability->contrast_ctrl.min_value);
    set(KEY_QC_MAX_CONTRAST, m_pCapability->contrast_ctrl.max_value);
    set(KEY_QC_CONTRAST_STEP, m_pCapability->contrast_ctrl.step);
    setContrast(m_pCapability->contrast_ctrl.def_value);

    // Set SCE factor
    set(KEY_QC_MIN_SCE_FACTOR, m_pCapability->sce_ctrl.min_value); // -100
    set(KEY_QC_MAX_SCE_FACTOR, m_pCapability->sce_ctrl.max_value); // 100
    set(KEY_QC_SCE_FACTOR_STEP, m_pCapability->sce_ctrl.step);     // 10
    setSkinToneEnhancement(m_pCapability->sce_ctrl.def_value);     // 0

    // Set Brightness
    set(KEY_QC_MIN_BRIGHTNESS, m_pCapability->brightness_ctrl.min_value); // 0
    set(KEY_QC_MAX_BRIGHTNESS, m_pCapability->brightness_ctrl.max_value); // 6
    set(KEY_QC_BRIGHTNESS_STEP, m_pCapability->brightness_ctrl.step);     // 1
    setBrightness(m_pCapability->brightness_ctrl.def_value);

    // Set Auto exposure
    String8 autoExposureValues = createValuesString(
            m_pCapability->supported_aec_modes,
            m_pCapability->supported_aec_modes_cnt,
            AUTO_EXPOSURE_MAP,
            PARAM_MAP_SIZE(AUTO_EXPOSURE_MAP));
    set(KEY_QC_SUPPORTED_AUTO_EXPOSURE, autoExposureValues.string());
    setAutoExposure(AUTO_EXPOSURE_FRAME_AVG);

    // Set Exposure Compensation
    set(KEY_MAX_EXPOSURE_COMPENSATION, m_pCapability->exposure_compensation_max); // 12
    set(KEY_MIN_EXPOSURE_COMPENSATION, m_pCapability->exposure_compensation_min); // -12
    setFloat(KEY_EXPOSURE_COMPENSATION_STEP, m_pCapability->exposure_compensation_step); // 1/6
    setExposureCompensation(m_pCapability->exposure_compensation_default); // 0

    // Set Instant AEC modes
    String8 instantAECModes = createValuesString(
            m_pCapability->supported_instant_aec_modes,
            m_pCapability->supported_instant_aec_modes_cnt,
            INSTANT_AEC_MODES_MAP,
            PARAM_MAP_SIZE(INSTANT_AEC_MODES_MAP));
    set(KEY_QC_INSTANT_AEC_SUPPORTED_MODES, instantAECModes.string());

    // Set Instant Capture modes
    String8 instantCaptureModes = createValuesString(
            m_pCapability->supported_instant_aec_modes,
            m_pCapability->supported_instant_aec_modes_cnt,
            INSTANT_CAPTURE_MODES_MAP,
            PARAM_MAP_SIZE(INSTANT_CAPTURE_MODES_MAP));
    set(KEY_QC_INSTANT_CAPTURE_SUPPORTED_MODES, instantCaptureModes.string());


    // Set Antibanding
    String8 antibandingValues = createValuesString(
            m_pCapability->supported_antibandings,
            m_pCapability->supported_antibandings_cnt,
            ANTIBANDING_MODES_MAP,
            PARAM_MAP_SIZE(ANTIBANDING_MODES_MAP));
    set(KEY_SUPPORTED_ANTIBANDING, antibandingValues);
    setAntibanding(ANTIBANDING_OFF);

    // Set Effect
    String8 effectValues = createValuesString(
            m_pCapability->supported_effects,
            m_pCapability->supported_effects_cnt,
            EFFECT_MODES_MAP,
            PARAM_MAP_SIZE(EFFECT_MODES_MAP));

    if (m_pCapability->supported_effects_cnt > 0) {
        set(KEY_SUPPORTED_EFFECTS, effectValues);
    } else {
        LOGW("Color effects are not available");
        set(KEY_SUPPORTED_EFFECTS, EFFECT_NONE);
    }
    setEffect(EFFECT_NONE);

    // Set WhiteBalance
    String8 whitebalanceValues = createValuesString(
            m_pCapability->supported_white_balances,
            m_pCapability->supported_white_balances_cnt,
            WHITE_BALANCE_MODES_MAP,
            PARAM_MAP_SIZE(WHITE_BALANCE_MODES_MAP));
    set(KEY_SUPPORTED_WHITE_BALANCE, whitebalanceValues);
    setWhiteBalance(WHITE_BALANCE_AUTO);

    // set supported wb cct, we should get them from m_pCapability
    m_pCapability->min_wb_cct = 2000;
    m_pCapability->max_wb_cct = 8000;
    set(KEY_QC_MIN_WB_CCT, m_pCapability->min_wb_cct);
    set(KEY_QC_MAX_WB_CCT, m_pCapability->max_wb_cct);

    // set supported wb rgb gains, ideally we should get them from m_pCapability
    //but for now hardcode.
    m_pCapability->min_wb_gain = 1.0;
    m_pCapability->max_wb_gain = 4.0;
    setFloat(KEY_QC_MIN_WB_GAIN, m_pCapability->min_wb_gain);
    setFloat(KEY_QC_MAX_WB_GAIN, m_pCapability->max_wb_gain);

    //set supported manual wb modes
    String8 manualWBModes(VALUE_OFF);
    if(m_pCapability->sensor_type.sens_type != CAM_SENSOR_YUV) {
        manualWBModes.append(",");
        manualWBModes.append(KEY_QC_WB_CCT_MODE);
        manualWBModes.append(",");
        manualWBModes.append(KEY_QC_WB_GAIN_MODE);
    }
    set(KEY_QC_SUPPORTED_MANUAL_WB_MODES, manualWBModes.string());

    // Set Flash mode
    if(m_pCapability->supported_flash_modes_cnt > 0) {
       String8 flashValues = createValuesString(
               m_pCapability->supported_flash_modes,
               m_pCapability->supported_flash_modes_cnt,
               FLASH_MODES_MAP,
               PARAM_MAP_SIZE(FLASH_MODES_MAP));
       set(KEY_SUPPORTED_FLASH_MODES, flashValues);
       setFlash(FLASH_MODE_OFF);
    } else {
        LOGW("supported flash modes cnt is 0!!!");
    }

    // Set Scene Mode
    String8 sceneModeValues = createValuesString(
            m_pCapability->supported_scene_modes,
            m_pCapability->supported_scene_modes_cnt,
            SCENE_MODES_MAP,
            PARAM_MAP_SIZE(SCENE_MODES_MAP));
    set(KEY_SUPPORTED_SCENE_MODES, sceneModeValues);
    setSceneMode(SCENE_MODE_AUTO);

    // Set CDS Mode
    String8 cdsModeValues = createValuesStringFromMap(
            CDS_MODES_MAP,
            PARAM_MAP_SIZE(CDS_MODES_MAP));
    set(KEY_QC_SUPPORTED_CDS_MODES, cdsModeValues);

    // Set video CDS Mode
    String8 videoCdsModeValues = createValuesStringFromMap(
            CDS_MODES_MAP,
            PARAM_MAP_SIZE(CDS_MODES_MAP));
    set(KEY_QC_SUPPORTED_VIDEO_CDS_MODES, videoCdsModeValues);

    // Set TNR Mode
    String8 tnrModeValues = createValuesStringFromMap(
            ON_OFF_MODES_MAP,
            PARAM_MAP_SIZE(ON_OFF_MODES_MAP));
    set(KEY_QC_SUPPORTED_TNR_MODES, tnrModeValues);

    // Set video TNR Mode
    String8 videoTnrModeValues = createValuesStringFromMap(
            ON_OFF_MODES_MAP,
            PARAM_MAP_SIZE(ON_OFF_MODES_MAP));
    set(KEY_QC_SUPPORTED_VIDEO_TNR_MODES, videoTnrModeValues);

    // Set ISO Mode
    String8 isoValues = createValuesString(
            m_pCapability->supported_iso_modes,
            m_pCapability->supported_iso_modes_cnt,
            ISO_MODES_MAP,
            PARAM_MAP_SIZE(ISO_MODES_MAP));
    set(KEY_QC_SUPPORTED_ISO_MODES, isoValues);
    setISOValue(ISO_AUTO);

    // Set exposure time
    String8 manualExpModes(VALUE_OFF);
    bool expTimeSupported = false;
    bool manualISOSupported = false;
    //capability values are in nano sec, convert to milli sec for upper layers
    char expTimeStr[20];
    double min_exp_time = (double) m_pCapability->exposure_time_range[0] / 1000000.0;
    double max_exp_time = (double) m_pCapability->exposure_time_range[1] / 1000000.0;
    snprintf(expTimeStr, sizeof(expTimeStr), "%f", min_exp_time);
    set(KEY_QC_MIN_EXPOSURE_TIME, expTimeStr);
    snprintf(expTimeStr, sizeof(expTimeStr), "%f", max_exp_time);
    set(KEY_QC_MAX_EXPOSURE_TIME, expTimeStr);
    if ((min_exp_time > 0) && (max_exp_time > min_exp_time)) {
        manualExpModes.append(",");
        manualExpModes.append(KEY_QC_EXP_TIME_PRIORITY);
        expTimeSupported = true;
    }
    LOGH(", Exposure time min %f ms, max %f ms",
            min_exp_time, max_exp_time);

    // Set iso
    set(KEY_QC_MIN_ISO, m_pCapability->sensitivity_range.min_sensitivity);
    set(KEY_QC_MAX_ISO, m_pCapability->sensitivity_range.max_sensitivity);
    LOGH(", ISO min %d, max %d",
            m_pCapability->sensitivity_range.min_sensitivity,
            m_pCapability->sensitivity_range.max_sensitivity);
    if ((m_pCapability->sensitivity_range.min_sensitivity > 0) &&
            (m_pCapability->sensitivity_range.max_sensitivity >
                    m_pCapability->sensitivity_range.min_sensitivity)) {
        manualExpModes.append(",");
        manualExpModes.append(KEY_QC_ISO_PRIORITY);
        manualISOSupported = true;
    }
    if (expTimeSupported && manualISOSupported) {
        manualExpModes.append(",");
        manualExpModes.append(KEY_QC_USER_SETTING);
    }
    //finally set supported manual exposure modes
    set(KEY_QC_SUPPORTED_MANUAL_EXPOSURE_MODES, manualExpModes.string());

    // Set HFR
    String8 hfrValues = createHfrValuesString(
            m_pCapability->hfr_tbl,
            m_pCapability->hfr_tbl_cnt,
            HFR_MODES_MAP,
            PARAM_MAP_SIZE(HFR_MODES_MAP));
    set(KEY_QC_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES, hfrValues.string());
    set(KEY_QC_VIDEO_HIGH_SPEED_RECORDING, "off");
    set(KEY_QC_VIDEO_HIGH_FRAME_RATE, "off");
    String8 hfrSizeValues = createHfrSizesString(
            m_pCapability->hfr_tbl,
            m_pCapability->hfr_tbl_cnt);
    set(KEY_QC_SUPPORTED_HFR_SIZES, hfrSizeValues.string());
    LOGD("HFR values = %s HFR Sizes = %s", hfrValues.string(), hfrSizeValues.string());
    setHighFrameRate(CAM_HFR_MODE_OFF);

    // Set Focus algorithms
    String8 focusAlgoValues = createValuesString(
            m_pCapability->supported_focus_algos,
            m_pCapability->supported_focus_algos_cnt,
            FOCUS_ALGO_MAP,
            PARAM_MAP_SIZE(FOCUS_ALGO_MAP));
    set(KEY_QC_SUPPORTED_FOCUS_ALGOS, focusAlgoValues);
    setSelectableZoneAf(FOCUS_ALGO_AUTO);

    // Set Zoom Ratios
    if (m_pCapability->zoom_supported > 0) {
        String8 zoomRatioValues = createZoomRatioValuesString(
                m_pCapability->zoom_ratio_tbl,
                m_pCapability->zoom_ratio_tbl_cnt);
        set(KEY_ZOOM_RATIOS, zoomRatioValues);
        set(KEY_MAX_ZOOM, (int)(m_pCapability->zoom_ratio_tbl_cnt - 1));
        setZoom(0);
    }

    // Set Bracketing/HDR
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));
    property_get("persist.capture.burst.exposures", prop, "");
    if (strlen(prop) > 0) {
        set(KEY_QC_CAPTURE_BURST_EXPOSURE, prop);
    }
    String8 bracketingValues = createValuesStringFromMap(
            BRACKETING_MODES_MAP,
            PARAM_MAP_SIZE(BRACKETING_MODES_MAP));
    set(KEY_QC_SUPPORTED_AE_BRACKET_MODES, bracketingValues);
    setAEBracket(AE_BRACKET_OFF);

    //Set AF Bracketing.
    for (size_t i = 0; i < m_pCapability->supported_focus_modes_cnt; i++) {
        if ((CAM_FOCUS_MODE_AUTO == m_pCapability->supported_focus_modes[i]) &&
                ((m_pCapability->qcom_supported_feature_mask &
                        CAM_QCOM_FEATURE_UBIFOCUS) > 0)) {
            String8 afBracketingValues = createValuesStringFromMap(
                    AF_BRACKETING_MODES_MAP,
                    PARAM_MAP_SIZE(AF_BRACKETING_MODES_MAP));
            set(KEY_QC_SUPPORTED_AF_BRACKET_MODES, afBracketingValues);
            setAFBracket(AF_BRACKET_OFF);
            break;
         }
    }

    //Set Refocus.
    //Re-use ubifocus flag for now.
    for (size_t i = 0; i < m_pCapability->supported_focus_modes_cnt; i++) {
        if ((CAM_FOCUS_MODE_AUTO == m_pCapability->supported_focus_modes[i]) &&
                (m_pCapability->qcom_supported_feature_mask &
                    CAM_QCOM_FEATURE_REFOCUS) > 0) {
            String8 reFocusValues = createValuesStringFromMap(
                    RE_FOCUS_MODES_MAP,
                    PARAM_MAP_SIZE(RE_FOCUS_MODES_MAP));
            set(KEY_QC_SUPPORTED_RE_FOCUS_MODES, reFocusValues);
            setReFocus(RE_FOCUS_OFF);
        }
    }

    //Set Chroma Flash.
    if ((m_pCapability->supported_flash_modes_cnt > 0) &&
            (m_pCapability->qcom_supported_feature_mask &
            CAM_QCOM_FEATURE_CHROMA_FLASH) > 0) {
        String8 chromaFlashValues = createValuesStringFromMap(
                CHROMA_FLASH_MODES_MAP,
                PARAM_MAP_SIZE(CHROMA_FLASH_MODES_MAP));
        set(KEY_QC_SUPPORTED_CHROMA_FLASH_MODES, chromaFlashValues);
        setChromaFlash(CHROMA_FLASH_OFF);
    }

    //Set Opti Zoom.
    if (m_pCapability->zoom_supported &&
            (m_pCapability->qcom_supported_feature_mask &
            CAM_QCOM_FEATURE_OPTIZOOM) > 0){
        String8 optiZoomValues = createValuesStringFromMap(
                OPTI_ZOOM_MODES_MAP,
                PARAM_MAP_SIZE(OPTI_ZOOM_MODES_MAP));
        set(KEY_QC_SUPPORTED_OPTI_ZOOM_MODES, optiZoomValues);
        setOptiZoom(OPTI_ZOOM_OFF);
    }

    //Set HDR Type
    uint32_t supported_hdr_modes = m_pCapability->qcom_supported_feature_mask &
            (CAM_QCOM_FEATURE_SENSOR_HDR | CAM_QCOM_FEATURE_HDR);
    if (supported_hdr_modes) {
        if (CAM_QCOM_FEATURE_SENSOR_HDR == supported_hdr_modes) {
            String8 hdrModeValues;
            hdrModeValues.append(HDR_MODE_SENSOR);
            set(KEY_QC_SUPPORTED_KEY_QC_HDR_MODES, hdrModeValues);
            setHDRMode(HDR_MODE_SENSOR);
        } else if (CAM_QCOM_FEATURE_HDR == supported_hdr_modes) {
            String8 hdrModeValues;
            hdrModeValues.append(HDR_MODE_MULTI_FRAME);
            set(KEY_QC_SUPPORTED_KEY_QC_HDR_MODES, hdrModeValues);
            setHDRMode(HDR_MODE_MULTI_FRAME);
        } else {
            String8 hdrModeValues = createValuesStringFromMap(
                    HDR_MODES_MAP,
                    PARAM_MAP_SIZE(HDR_MODES_MAP));
            set(KEY_QC_SUPPORTED_KEY_QC_HDR_MODES, hdrModeValues);
            setHDRMode(HDR_MODE_MULTI_FRAME);
        }
    }

    //Set HDR need 1x
    String8 hdrNeed1xValues;
    if (!m_bHDRModeSensor) {
        hdrNeed1xValues = createValuesStringFromMap(TRUE_FALSE_MODES_MAP,
                PARAM_MAP_SIZE(TRUE_FALSE_MODES_MAP));
    } else {
        hdrNeed1xValues.append(VALUE_FALSE);
    }
    setHDRNeed1x(VALUE_FALSE);
    set(KEY_QC_SUPPORTED_HDR_NEED_1X, hdrNeed1xValues);

    //Set True Portrait
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_TRUEPORTRAIT) > 0) {
        String8 truePortraitValues = createValuesStringFromMap(
                TRUE_PORTRAIT_MODES_MAP,
                PARAM_MAP_SIZE(TRUE_PORTRAIT_MODES_MAP));
        set(KEY_QC_SUPPORTED_TRUE_PORTRAIT_MODES, truePortraitValues);
    }

    // Set Denoise
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_DENOISE2D) > 0){
    String8 denoiseValues = createValuesStringFromMap(
        DENOISE_ON_OFF_MODES_MAP, PARAM_MAP_SIZE(DENOISE_ON_OFF_MODES_MAP));
    set(KEY_QC_SUPPORTED_DENOISE, denoiseValues.string());
#ifdef DEFAULT_DENOISE_MODE_ON
    setWaveletDenoise(DENOISE_ON);
#else
    setWaveletDenoise(DENOISE_OFF);
#endif
    }

    // Set feature enable/disable
    String8 enableDisableValues = createValuesStringFromMap(
            ENABLE_DISABLE_MODES_MAP, PARAM_MAP_SIZE(ENABLE_DISABLE_MODES_MAP));

    // Set Lens Shading
    set(KEY_QC_SUPPORTED_LENSSHADE_MODES, enableDisableValues);
    setLensShadeValue(VALUE_ENABLE);
    // Set MCE
    set(KEY_QC_SUPPORTED_MEM_COLOR_ENHANCE_MODES, enableDisableValues);
    setMCEValue(VALUE_ENABLE);

    // Set DIS
    set(KEY_QC_SUPPORTED_DIS_MODES, enableDisableValues);
    setDISValue(VALUE_DISABLE);

    // Set Histogram
    set(KEY_QC_SUPPORTED_HISTOGRAM_MODES,
        m_pCapability->histogram_supported ? enableDisableValues : "");
    set(KEY_QC_HISTOGRAM, VALUE_DISABLE);

    //Set Red Eye Reduction
    set(KEY_QC_SUPPORTED_REDEYE_REDUCTION, enableDisableValues);
    setRedeyeReduction(VALUE_DISABLE);

    //Set SkinTone Enhancement
    set(KEY_QC_SUPPORTED_SKIN_TONE_ENHANCEMENT_MODES, enableDisableValues);

    // Enable LTM by default and disable it in HDR & SeeMore usecases
    setToneMapMode(true, false);

    // Set feature on/off
    String8 onOffValues = createValuesStringFromMap(
            ON_OFF_MODES_MAP, PARAM_MAP_SIZE(ON_OFF_MODES_MAP));

    //Set See more (LLVD)
    if (m_pCapability->qcom_supported_feature_mask &
            CAM_QCOM_FEATURE_LLVD) {
        set(KEY_QC_SUPPORTED_SEE_MORE_MODES, onOffValues);
        setSeeMore(VALUE_OFF);
    }

    //Set Still more
    if (m_pCapability->qcom_supported_feature_mask &
            CAM_QCOM_FEATURE_STILLMORE) {
        String8 stillMoreValues = createValuesStringFromMap(
                STILL_MORE_MODES_MAP,
                PARAM_MAP_SIZE(STILL_MORE_MODES_MAP));
        set(KEY_QC_SUPPORTED_STILL_MORE_MODES, stillMoreValues);
        setStillMore(STILL_MORE_OFF);
    }

    //Set Noise Reduction mode
    if (m_pCapability->qcom_supported_feature_mask &
            CAM_QTI_FEATURE_SW_TNR) {
        String8 noiseReductionModesValues = createValuesStringFromMap(
                NOISE_REDUCTION_MODES_MAP, PARAM_MAP_SIZE(NOISE_REDUCTION_MODES_MAP));
        set(KEY_QC_NOISE_REDUCTION_MODE_VALUES, noiseReductionModesValues);
        setNoiseReductionMode(VALUE_OFF);
    }

    //Set Scene Detection
    set(KEY_QC_SUPPORTED_SCENE_DETECT, onOffValues);
    setSceneDetect(VALUE_OFF);
    m_bHDREnabled = false;
    m_bHDR1xFrameEnabled = false;

    m_bHDRThumbnailProcessNeeded = false;
    m_bHDR1xExtraBufferNeeded = true;
    for (uint32_t i=0; i<m_pCapability->hdr_bracketing_setting.num_frames; i++) {
        if (0 == m_pCapability->hdr_bracketing_setting.exp_val.values[i]) {
            m_bHDR1xExtraBufferNeeded = false;
            break;
        }
    }

    // Set HDR output scaling
    char value[PROPERTY_VALUE_MAX];

    property_get("persist.camera.hdr.outcrop", value, VALUE_DISABLE);
    if (strncmp(VALUE_ENABLE, value, sizeof(VALUE_ENABLE))) {
      m_bHDROutputCropEnabled = false;
    } else {
      m_bHDROutputCropEnabled = true;
    }

    //Set Face Detection
    set(KEY_QC_SUPPORTED_FACE_DETECTION, onOffValues);
    set(KEY_QC_FACE_DETECTION, VALUE_OFF);

    //Set Face Recognition
    //set(KEY_QC_SUPPORTED_FACE_RECOGNITION, onOffValues);
    //set(KEY_QC_FACE_RECOGNITION, VALUE_OFF);

    //Set ZSL
    set(KEY_QC_SUPPORTED_ZSL_MODES, onOffValues);
#ifdef DEFAULT_ZSL_MODE_ON
    set(KEY_QC_ZSL, VALUE_ON);
    m_bZslMode = true;
#else
    set(KEY_QC_ZSL, VALUE_OFF);
    m_bZslMode = false;
#endif

    // Check if zsl mode property is enabled.
    // If yes, force the camera to be in zsl mode
    // and force zsl mode to be enabled in dual camera mode.
    memset(value, 0x0, PROPERTY_VALUE_MAX);
    property_get("persist.camera.zsl.mode", value, "0");
    int32_t zsl_mode = atoi(value);
    if((zsl_mode == 1) ||
            (m_bZslMode == true) ||
            (m_relCamSyncInfo.sync_control == CAM_SYNC_RELATED_SENSORS_ON)) {
        LOGH("%d: Forcing Camera to ZSL mode enabled");
        set(KEY_QC_ZSL, VALUE_ON);
        m_bForceZslMode = true;
        m_bZslMode = true;
        int32_t value = m_bForceZslMode;
        ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_ZSL_MODE, value);
    }
    m_bZslMode_new = m_bZslMode;

    set(KEY_QC_SCENE_SELECTION, VALUE_DISABLE);

    // Rdi mode
    set(KEY_QC_SUPPORTED_RDI_MODES, enableDisableValues);
    setRdiMode(VALUE_DISABLE);

    // Secure mode
    set(KEY_QC_SUPPORTED_SECURE_MODES, enableDisableValues);
    setSecureMode(VALUE_DISABLE);

    //Set video HDR
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_VIDEO_HDR) > 0) {
        set(KEY_QC_SUPPORTED_VIDEO_HDR_MODES, onOffValues);
        set(KEY_QC_VIDEO_HDR, VALUE_OFF);
    }

    //Set HW Sensor Snapshot HDR
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_SENSOR_HDR)> 0) {
        set(KEY_QC_SUPPORTED_SENSOR_HDR_MODES, onOffValues);
        set(KEY_QC_SENSOR_HDR, VALUE_OFF);
        m_bSensorHDREnabled = false;
    }

    // Set VT TimeStamp
    set(KEY_QC_VT_ENABLE, VALUE_DISABLE);
    //Set Touch AF/AEC
    String8 touchValues = createValuesStringFromMap(
            TOUCH_AF_AEC_MODES_MAP, PARAM_MAP_SIZE(TOUCH_AF_AEC_MODES_MAP));

    set(KEY_QC_SUPPORTED_TOUCH_AF_AEC, touchValues);
    set(KEY_QC_TOUCH_AF_AEC, TOUCH_AF_AEC_OFF);

    //set flip mode
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_FLIP) > 0) {
        String8 flipModes = createValuesStringFromMap(
                FLIP_MODES_MAP, PARAM_MAP_SIZE(FLIP_MODES_MAP));
        set(KEY_QC_SUPPORTED_FLIP_MODES, flipModes);
        set(KEY_QC_PREVIEW_FLIP, FLIP_MODE_OFF);
        set(KEY_QC_VIDEO_FLIP, FLIP_MODE_OFF);
        set(KEY_QC_SNAPSHOT_PICTURE_FLIP, FLIP_MODE_OFF);
    }

    // Set default Auto Exposure lock value
    setAecLock(VALUE_FALSE);

    // Set default AWB_LOCK lock value
    setAwbLock(VALUE_FALSE);

    // Set default Camera mode
    set(KEY_QC_CAMERA_MODE, 0);

    // Add support for internal preview restart
    set(KEY_INTERNAL_PERVIEW_RESTART, VALUE_TRUE);
    // Set default burst number
    set(KEY_QC_SNAPSHOT_BURST_NUM, 0);
    set(KEY_QC_NUM_RETRO_BURST_PER_SHUTTER, 0);

    //Get RAM size and disable features which are memory rich
    struct sysinfo info;
    sysinfo(&info);

    LOGH("totalram = %ld, freeram = %ld ", info.totalram,
        info.freeram);
    if (info.totalram > TOTAL_RAM_SIZE_512MB) {
        set(KEY_QC_ZSL_HDR_SUPPORTED, VALUE_TRUE);
    } else {
        m_bIsLowMemoryDevice = true;
        set(KEY_QC_ZSL_HDR_SUPPORTED, VALUE_FALSE);
    }

    setOfflineRAW();
    memset(mStreamPpMask, 0, sizeof(cam_feature_mask_t)*CAM_STREAM_TYPE_MAX);
    //Set video buffers as uncached by default
    set(KEY_QC_CACHE_VIDEO_BUFFERS, VALUE_DISABLE);

    // Set default longshot mode
    set(KEY_QC_LONG_SHOT, "off");
    //Enable longshot by default
    set(KEY_QC_LONGSHOT_SUPPORTED, VALUE_TRUE);

    int32_t rc = commitParameters();
    if (rc == NO_ERROR) {
        rc = setNumOfSnapshot();
    }

    //Set Video Rotation
    String8 videoRotationValues = createValuesStringFromMap(VIDEO_ROTATION_MODES_MAP,
            PARAM_MAP_SIZE(VIDEO_ROTATION_MODES_MAP));

    set(KEY_QC_SUPPORTED_VIDEO_ROTATION_VALUES, videoRotationValues.string());
    set(KEY_QC_VIDEO_ROTATION, VIDEO_ROTATION_0);

    //Check for EZTune
    setEztune();
    //Default set for video batch size
    set(KEY_QC_VIDEO_BATCH_SIZE, 0);

    //Setup dual-camera
    setDcrf();

    // For Aux Camera of dual camera Mode,
    // by default set no display mode
    if (m_relCamSyncInfo.mode == CAM_MODE_SECONDARY) {
        set(KEY_QC_NO_DISPLAY_MODE, 1);
        m_bNoDisplayMode = true;
    }

    cam_dimension_t pic_dim;
    pic_dim.width = 0;
    pic_dim.height = 0;

    if (m_pCapability->picture_sizes_tbl_cnt > 0 &&
        m_pCapability->picture_sizes_tbl_cnt <= MAX_SIZES_CNT) {
        for(uint32_t i = 0;
                i < m_pCapability->picture_sizes_tbl_cnt; i++) {
            if ((pic_dim.width * pic_dim.height) <
                    (int32_t)(m_pCapability->picture_sizes_tbl[i].width *
                    m_pCapability->picture_sizes_tbl[i].height)) {
                pic_dim.width =
                        m_pCapability->picture_sizes_tbl[i].width;
                pic_dim.height =
                        m_pCapability->picture_sizes_tbl[i].height;
            }
        }
        LOGD("max pic size = %d %d", pic_dim.width,
                pic_dim.height);
        setMaxPicSize(pic_dim);
    } else {
        LOGW("supported picture sizes cnt is 0 or exceeds max!!!");
    }

    setManualCaptureMode(CAM_MANUAL_CAPTURE_TYPE_OFF);

    return rc;
}

/*===========================================================================
 * FUNCTION   : allocate
 *
 * DESCRIPTION: Allocate buffer memory for parameter obj (if necessary)
 *
 * PARAMETERS : none
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::allocate()
{
    int32_t rc = NO_ERROR;

    if (m_pParamHeap != NULL) {
        return rc;
    }

    //Allocate Set Param Buffer
    m_pParamHeap = new QCameraHeapMemory(QCAMERA_ION_USE_CACHE);
    if (m_pParamHeap == NULL) {
        return NO_MEMORY;
    }

    rc = m_pParamHeap->allocate(1, sizeof(parm_buffer_t), NON_SECURE);
    if(rc != OK) {
        rc = NO_MEMORY;
        LOGE("Error!! Param buffers have not been allocated");
        delete m_pParamHeap;
        m_pParamHeap = NULL;
    }

    return rc;
}

/*===========================================================================
 * FUNCTION   : init
 *
 * DESCRIPTION: initialize parameter obj
 *
 * PARAMETERS :
 *   @capabilities  : ptr to camera capabilities
 *   @mmops         : ptr to memory ops table for mapping/unmapping
 *   @adjustFPS     : object reference for additional (possibly thermal)
 *                    framerate adjustment
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::init(cam_capability_t *capabilities,
        mm_camera_vtbl_t *mmOps, QCameraAdjustFPS *adjustFPS)
{
    int32_t rc = NO_ERROR;

    m_pCapability = capabilities;
    m_pCamOpsTbl = mmOps;
    m_AdjustFPS = adjustFPS;

    if (m_pParamHeap == NULL) {
        LOGE("Parameter buffers have not been allocated");
        rc = UNKNOWN_ERROR;
        goto TRANS_INIT_ERROR1;
    }

    //Map memory for parameters buffer
    cam_buf_map_type_list bufMapList;
    rc = QCameraBufferMaps::makeSingletonBufMapList(
            CAM_MAPPING_BUF_TYPE_PARM_BUF, 0 /*stream id*/,
            0 /*buffer index*/, -1 /*plane index*/, 0 /*cookie*/,
            m_pParamHeap->getFd(0), sizeof(parm_buffer_t), bufMapList,
                    m_pParamHeap->getPtr(0));

    if (rc == NO_ERROR) {
        rc = m_pCamOpsTbl->ops->map_bufs(m_pCamOpsTbl->camera_handle,
                &bufMapList);
    }

    if(rc < 0) {
        LOGE("failed to map SETPARM buffer");
        rc = FAILED_TRANSACTION;
        goto TRANS_INIT_ERROR2;
    }
    m_pParamBuf = (parm_buffer_t*) DATA_PTR(m_pParamHeap,0);

    // Check if it is dual camera mode
    if(m_relCamSyncInfo.sync_control == CAM_SYNC_RELATED_SENSORS_ON) {
        //Allocate related cam sync buffer
        //this is needed for the payload that goes along with bundling cmd for related
        //camera use cases
        m_pRelCamSyncHeap = new QCameraHeapMemory(QCAMERA_ION_USE_CACHE);
        rc = m_pRelCamSyncHeap->allocate(1,
                sizeof(cam_sync_related_sensors_event_info_t), NON_SECURE);
        if(rc != OK) {
            rc = NO_MEMORY;
            LOGE("Failed to allocate Related cam sync Heap memory");
            goto TRANS_INIT_ERROR3;
        }

        //Map memory for related cam sync buffer
        rc = m_pCamOpsTbl->ops->map_buf(m_pCamOpsTbl->camera_handle,
                CAM_MAPPING_BUF_TYPE_SYNC_RELATED_SENSORS_BUF,
                m_pRelCamSyncHeap->getFd(0),
                sizeof(cam_sync_related_sensors_event_info_t),
                (cam_sync_related_sensors_event_info_t*)DATA_PTR(m_pRelCamSyncHeap,0));
        if(rc < 0) {
            LOGE("failed to map Related cam sync buffer");
            rc = FAILED_TRANSACTION;
            goto TRANS_INIT_ERROR4;
        }
        m_pRelCamSyncBuf =
                (cam_sync_related_sensors_event_info_t*) DATA_PTR(m_pRelCamSyncHeap,0);
    }
    initDefaultParameters();
    mCommon.init(capabilities);
    m_bInited = true;

    goto TRANS_INIT_DONE;

TRANS_INIT_ERROR4:
    m_pRelCamSyncHeap->deallocate();

TRANS_INIT_ERROR3:
    delete m_pRelCamSyncHeap;
    m_pRelCamSyncHeap = NULL;

TRANS_INIT_ERROR2:
    m_pParamHeap->deallocate();
    delete m_pParamHeap;
    m_pParamHeap = NULL;

TRANS_INIT_ERROR1:
    m_pCapability = NULL;
    m_pCamOpsTbl = NULL;
    m_AdjustFPS = NULL;

TRANS_INIT_DONE:
    return rc;
}

/*===========================================================================
 * FUNCTION   : deinit
 *
 * DESCRIPTION: deinitialize
 *
 * PARAMETERS : none
 *
 * RETURN     : none
 *==========================================================================*/
void QCameraParameters::deinit()
{
    if (NULL != m_pParamHeap) {
        m_pParamHeap->deallocate();
        delete m_pParamHeap;
        m_pParamHeap = NULL;
        m_pParamBuf = NULL;
    }

    if (!m_bInited) {
        return;
    }

    //clear all entries in the map
    String8 emptyStr;
    QCameraParameters::unflatten(emptyStr);

    if ((NULL != m_pCamOpsTbl) && (m_pCamOpsTbl->ops != NULL)) {
        m_pCamOpsTbl->ops->unmap_buf(
                             m_pCamOpsTbl->camera_handle,
                             CAM_MAPPING_BUF_TYPE_PARM_BUF);

        if (m_relCamSyncInfo.sync_control == CAM_SYNC_RELATED_SENSORS_ON) {
            m_pCamOpsTbl->ops->unmap_buf(
                    m_pCamOpsTbl->camera_handle,
                    CAM_MAPPING_BUF_TYPE_SYNC_RELATED_SENSORS_BUF);
        }
    }

    m_pCapability = NULL;

    if (NULL != m_pRelCamSyncHeap) {
        m_pRelCamSyncHeap->deallocate();
        delete m_pRelCamSyncHeap;
        m_pRelCamSyncHeap = NULL;
        m_pRelCamSyncBuf = NULL;
    }

    m_AdjustFPS = NULL;
    m_tempMap.clear();
    m_pCamOpsTbl = NULL;
    m_AdjustFPS = NULL;

    m_bInited = false;
}

/*===========================================================================
 * FUNCTION   : parse_pair
 *
 * DESCRIPTION: helper function to parse string like "640x480" or "10000,20000"
 *
 * PARAMETERS :
 *   @str     : input string to be parse
 *   @first   : [output] first value of the pair
 *   @second  : [output]  second value of the pair
 *   @delim   : [input] delimeter to seperate the pair
 *   @endptr  : [output] ptr to the end of the pair string
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::parse_pair(const char *str,
                                      int *first,
                                      int *second,
                                      char delim,
                                      char **endptr = NULL)
{
    // Find the first integer.
    char *end;
    int w = (int)strtol(str, &end, 10);
    // If a delimeter does not immediately follow, give up.
    if (*end != delim) {
        LOGE("Cannot find delimeter (%c) in str=%s", delim, str);
        return BAD_VALUE;
    }

    // Find the second integer, immediately after the delimeter.
    int h = (int)strtol(end+1, &end, 10);

    *first = w;
    *second = h;

    if (endptr) {
        *endptr = end;
    }

    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : parseSizesList
 *
 * DESCRIPTION: helper function to parse string containing sizes
 *
 * PARAMETERS :
 *   @sizesStr: [input] input string to be parse
 *   @sizes   : [output] reference to store parsed sizes
 *
 * RETURN     : none
 *==========================================================================*/
void QCameraParameters::parseSizesList(const char *sizesStr, Vector<Size> &sizes)
{
    if (sizesStr == 0) {
        return;
    }

    char *sizeStartPtr = (char *)sizesStr;

    while (true) {
        int width, height;
        int success = parse_pair(sizeStartPtr, &width, &height, 'x',
                                 &sizeStartPtr);
        if (success == -1 || (*sizeStartPtr != ',' && *sizeStartPtr != '\0')) {
            LOGE("Picture sizes string \"%s\" contains invalid character.", sizesStr);
            return;
        }
        sizes.push(Size(width, height));

        if (*sizeStartPtr == '\0') {
            return;
        }
        sizeStartPtr++;
    }
}

/*===========================================================================
 * FUNCTION   : adjustPreviewFpsRange
 *
 * DESCRIPTION: adjust preview FPS ranges
 *              according to external events
 *
 * PARAMETERS :
 *   @minFPS  : min FPS value
 *   @maxFPS  : max FPS value
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::adjustPreviewFpsRange(cam_fps_range_t *fpsRange)
{
    if ( fpsRange == NULL ) {
        return BAD_VALUE;
    }

    if ( m_pParamBuf == NULL ) {
        return NO_INIT;
    }

    int32_t rc = initBatchUpdate(m_pParamBuf);
    if ( rc != NO_ERROR ) {
        LOGE("Failed to initialize group update table");
        return rc;
    }

    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_FPS_RANGE, *fpsRange)) {
        LOGE("Parameters batch failed");
        return BAD_VALUE;
    }

    rc = commitSetBatch();
    if ( rc != NO_ERROR ) {
        LOGE("Failed to commit batch parameters");
        return rc;
    }

    return rc;
}

/*===========================================================================
 * FUNCTION   : setPreviewFpsRanges
 *
 * DESCRIPTION: set preview FPS ranges
 *
 * PARAMETERS :
 *   @minFPS  : min FPS value
 *   @maxFPS  : max FPS value
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setPreviewFpsRange(int min_fps,
        int max_fps, int vid_min_fps,int vid_max_fps)
{
    char str[32];
    char value[PROPERTY_VALUE_MAX];
    int fixedFpsValue;
    /*This property get value should be the fps that user needs*/
    property_get("persist.debug.set.fixedfps", value, "0");
    fixedFpsValue = atoi(value);

    LOGD("E minFps = %d, maxFps = %d , vid minFps = %d, vid maxFps = %d",
                 min_fps, max_fps, vid_min_fps, vid_max_fps);

    if(fixedFpsValue != 0) {
        min_fps = max_fps = fixedFpsValue*1000;
        if (!isHfrMode()) {
             vid_min_fps = vid_max_fps = fixedFpsValue*1000;
        }
    }
    snprintf(str, sizeof(str), "%d,%d", min_fps, max_fps);
    LOGH("Setting preview fps range %s", str);
    updateParamEntry(KEY_PREVIEW_FPS_RANGE, str);
    cam_fps_range_t fps_range;
    memset(&fps_range, 0x00, sizeof(cam_fps_range_t));
    fps_range.min_fps = (float)min_fps / 1000.0f;
    fps_range.max_fps = (float)max_fps / 1000.0f;
    fps_range.video_min_fps = (float)vid_min_fps / 1000.0f;
    fps_range.video_max_fps = (float)vid_max_fps / 1000.0f;

    LOGH("Updated: minFps = %d, maxFps = %d ,"
            " vid minFps = %d, vid maxFps = %d",
             min_fps, max_fps, vid_min_fps, vid_max_fps);

    if ( NULL != m_AdjustFPS ) {
        if (m_ThermalMode == QCAMERA_THERMAL_ADJUST_FPS &&
                !m_bRecordingHint_new) {
            float minVideoFps = min_fps, maxVideoFps = max_fps;
            if (isHfrMode()) {
                minVideoFps = m_hfrFpsRange.video_min_fps;
                maxVideoFps = m_hfrFpsRange.video_max_fps;
            }
            m_AdjustFPS->recalcFPSRange(min_fps, max_fps, minVideoFps,
                                         maxVideoFps, fps_range, m_bRecordingHint_new);
            LOGH("Thermal adjusted Preview fps range %3.2f,%3.2f, %3.2f, %3.2f",
                   fps_range.min_fps, fps_range.max_fps,
                  fps_range.video_min_fps, fps_range.video_max_fps);
        }
    }

    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_FPS_RANGE, fps_range)) {
        return BAD_VALUE;
    }

    return NO_ERROR;
}



/*===========================================================================
 * FUNCTION   : setAutoExposure
 *
 * DESCRIPTION: set auto exposure
 *
 * PARAMETERS :
 *   @autoExp : auto exposure value string
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setAutoExposure(const char *autoExp)
{
    if (autoExp != NULL) {
        int32_t value = lookupAttr(AUTO_EXPOSURE_MAP, PARAM_MAP_SIZE(AUTO_EXPOSURE_MAP), autoExp);
        if (value != NAME_NOT_FOUND) {
            LOGH("Setting auto exposure %s", autoExp);
            updateParamEntry(KEY_QC_AUTO_EXPOSURE, autoExp);
            if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_AEC_ALGO_TYPE, value)) {
                return BAD_VALUE;
            }
            return NO_ERROR;
        }
    }
    LOGE("Invalid auto exposure value: %s", (autoExp == NULL) ? "NULL" : autoExp);
    return BAD_VALUE;
}

/*===========================================================================
 * FUNCTION   : setEffect
 *
 * DESCRIPTION: set effect
 *
 * PARAMETERS :
 *   @effect  : effect value string
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setEffect(const char *effect)
{
    if (effect != NULL) {
        int32_t value = lookupAttr(EFFECT_MODES_MAP, PARAM_MAP_SIZE(EFFECT_MODES_MAP), effect);
        if (value != NAME_NOT_FOUND) {
            LOGH("Setting effect %s", effect);
            updateParamEntry(KEY_EFFECT, effect);
            uint8_t prmEffect = static_cast<uint8_t>(value);
            mParmEffect = prmEffect;
            if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_EFFECT, prmEffect)) {
                return BAD_VALUE;
            }
            return NO_ERROR;
        }
    }
    LOGE("Invalid effect value: %s", (effect == NULL) ? "NULL" : effect);
    return BAD_VALUE;
}

/*===========================================================================
 * FUNCTION   : setBrightness
 *
 * DESCRIPTION: set brightness control value
 *
 * PARAMETERS :
 *   @brightness  : brightness control value
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setBrightness(int brightness)
{
    char val[16];
    snprintf(val, sizeof(val), "%d", brightness);
    updateParamEntry(KEY_QC_BRIGHTNESS, val);

    LOGH("Setting brightness %s", val);
    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_BRIGHTNESS, brightness)) {
        return BAD_VALUE;
    }

    return NO_ERROR;
}

/*===========================================================================
 * FUNCTION   : setFocusMode
 *
 * DESCRIPTION: set focus mode
 *
 * PARAMETERS :
 *   @focusMode  : focus mode value string
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t QCameraParameters::setFocusMode(const char *focusMode)
{
    if (focusMode != NULL) {
        int32_t value = lookupAttr(FOCUS_MODES_MAP, PARAM_MAP_SIZE(FOCUS_MODES_MAP), focusMode);
        if (value != NAME_NOT_FOUND) {
            int32_t rc = NO_ERROR;
            LOGH("Setting focus mode %s", focusMode);
            mFocusMode = (cam_focus_mode_type)value;

            updateParamEntry(KEY_FOCUS_MODE, focusMode);
            if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf,
                    CAM_INTF_PARM_FOCUS_MODE, (uint8_t)value)) {
                rc = BAD_VALUE;
            }
            if (strcmp(focusMode,"infinity")==0){
                set(QCameraParameters::KEY_FOCUS_DISTANCES, "Infinity,Infinity,Infinity");
            }
            return rc;
        }
    }
    LOGE("Invalid focus mode value: %s", (focusMode == NULL) ? "NULL" : focusMode);
    return BAD_VALUE;
}

/*===========================================================================
 * FUNCTION   : setFocusPosition
 *
 * DESCRIPTION: set focus position
 *
 * PARAMETERS :
 *   @typeStr : focus position type, index or dac_code
 *   @posStr : focus positon.
 *
 * RETURN     : int32_t type of status
 *              NO_ERROR  -- success
 *              none-zero failure code
 *==========================================================================*/
int32_t  QCameraParameters::setFocusPosition(const char *typeStr, const char *posStr)
{
    LOGH(", type:%s, pos: %s", typeStr, posStr);
    int32_t type = atoi(typeStr);
    float pos = (float) atof(posStr);

    if ((type >= CAM_MANUAL_FOCUS_MODE_INDEX) &&
            (type < CAM_MANUAL_FOCUS_MODE_MAX)) {
        // get max and min focus position from m_pCapability
        float minFocusPos = m_pCapability->min_focus_pos[type];
        float maxFocusPos = m_pCapability->max_focus_pos[type];
        LOGH(", focusPos min: %f, max: %f", minFocusPos, maxFocusPos);

        if (pos >= minFocusPos && pos <= maxFocusPos) {
            updateParamEntry(KEY_QC_MANUAL_FOCUS_POS_TYPE, typeStr);
            updateParamEntry(KEY_QC_MANUAL_FOCUS_POSITION, posStr);

            cam_manual_focus_parm_t manual_focus;
            manual_focus.flag = (cam_manual_focus_mode_type)type;
            if (manual_focus.flag == CAM_MANUAL_FOCUS_MODE_DIOPTER) {
                manual_focus.af_manual_diopter = pos;
            } else if (manual_focus.flag == CAM_MANUAL_FOCUS_MODE_RATIO) {
                manual_focus.af_manual_lens_position_ratio = (int32_t) pos;
            } else if (manual_focus.flag == CAM_MANUAL_FOCUS_MODE_INDEX) {
                manual_focus.af_manual_lens_position_index = (int32_t) pos;
            } else {
                manual_focus.af_manual_lens_position_dac = (int32_t) pos;
            }

            if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_MANUAL_FOCUS_POS,
                    manual_focus)) {
                return BAD_VALUE;
            }
            return NO_ERROR;
        }
    }

    LOGE("invalid params, type:%d, pos: %f", type, pos);
    return BAD_VALUE;
}

/*===========================================================================
 * FUNCTION   : updateAEInfo
 *
 * DESCRIPTION: update exposure information from metadata callback
 *
 * PARAMETERS :
 *   @ae_params : auto exposure params
 *
 * RETURN     : void
 *==========================================================================*/
void  QCameraParameters::updateAEInfo(cam_3a_params_t &ae_params)
{
    const char *prevExpTime = get(KEY_QC_CURRENT_EXPOSURE_TIME);
    char newExpTime[15];
    snprintf(newExpTime, sizeof(newExpTime), "%f", ae_params.exp_time*1000.0);

    if (prevExpTime == NULL || strcmp(prevExpTime, newExpTime)) {
        LOGD("update exposure time: old: %s, new: %s", prevExpTime, newExpTime);
        set(KEY_QC_CURRENT_EXPOSURE_TIME, newExpTime);
    }

    int32_t prevISO = getInt(KEY_QC_CURRENT_ISO);
    int32_t newISO = ae_params.iso_value;
    if (prevISO != newISO) {
        LOGD("update iso: old:%d, new:%d", prevISO, newISO);
        set(KEY_QC_CURRENT_ISO, newISO);
    }
}

/*===========================================================================
 * FUNCTION   : updateCurrentFocusPosition
 *
 * DESCRIPTION: update current focus position from metadata callback
 *
 * PARAMETERS :
 *   @pos : current focus position
 *
 * RETURN     : void
 *==========================================================================*/
void  QCameraParameters::updateCurrentFocusPosition(cam_focus_pos_info_t &cur_pos_info)
{
    int prevScalePos = getInt(KEY_QC_FOCUS_POSITION_SCALE);
    int newScalePos = (int) cur_pos_info.scale;
    if (prevScalePos != newScalePos) {
        LOGD("update focus scale: old